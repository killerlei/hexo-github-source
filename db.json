{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/GNAME","path":"GNAME","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.234bc0.css","path":"main.234bc0.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.d238ee.js","path":"mobile.d238ee.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.885efe.js","path":"slider.885efe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.234bc0.js","path":"main.234bc0.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","path":"fonts/iconfont.3a9902.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","path":"fonts/iconfont.6e162c.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","path":"fonts/iconfont.9abe9f.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","path":"fonts/iconfont.d0da7e.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/GNAME","hash":"e4a86643263969cda8fea06a8ce5a80f2a727c71","modified":1536943110817},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1536943110842},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1536943110842},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1536943110842},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1536943110842},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1536943110842},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1536943110843},{"_id":"themes/yilia/README.md","hash":"a6aea7cf499638187bb5d005526d6c0fc213f697","modified":1536943110843},{"_id":"themes/yilia/_config.yml","hash":"2e74571ab9f52547b00f27648d688f5f3915b899","modified":1536943110843},{"_id":"themes/yilia/package.json","hash":"946b26ae0dff42c590068f0a58ecd326ed059b68","modified":1536943110851},{"_id":"themes/yilia/webpack.config.js","hash":"c4dca5c60822c90359e48fad373be768ae9fb43d","modified":1536943110868},{"_id":"source/_posts/hexo-github-AppVeyor实现不同电脑写博客.md","hash":"2dedf1f691b730ae7f6152a65a4c6d3ce9584af5","modified":1536943110817},{"_id":"source/_posts/jsonp使用及promise封装.md","hash":"599d823556cc4b235f2550e76838c1bb3fe5c845","modified":1536943110818},{"_id":"source/_posts/swiper-animal-冲突解决.md","hash":"4c175f86b506fc7f4f87f323ce0777406e39cf3f","modified":1536943110818},{"_id":"source/_posts/vue-cli-2-中webpack的配置-一.md","hash":"9b1d6b9f3364d9bfa73cf71ab3957540bea3f4c8","modified":1536943110818},{"_id":"source/_posts/vue-cli-2中webpack的配置分析二.md","hash":"6f5dbb193df66039b326903d650657d062a5ad53","modified":1536943110818},{"_id":"source/_posts/vue-cli中process-env-NODE-ENV.md","hash":"e2c063021fcdbd24b046d96a9b45de68d8fada90","modified":1536943110818},{"_id":"source/_posts/vue-cli编译打包后起node服务测试.md","hash":"fab7c98bcc8ccd839ee849bbebdf9a8b1ac0204c","modified":1536943110818},{"_id":"source/_posts/vue开发跨域解决办法.md","hash":"ebb1cd9ebe8bf5ad76335f06b04e07723d03f1e0","modified":1536943110819},{"_id":"source/_posts/webpack总结-一.md","hash":"8cc96002908054fd7cbdf2fb1126d32cc2b71530","modified":1536943110819},{"_id":"source/_posts/webpack总结三.md","hash":"0d93bdf92bbe8489009df25444355e63e4393108","modified":1536943110819},{"_id":"source/_posts/使用代理解决跨域限制.md","hash":"5c04e51b75c50154d7fa45f81b45e0783e20c6ee","modified":1536943110819},{"_id":"source/_posts/webpack总结二.md","hash":"e89a908869f8d22062ad1109cfb271650a95ef71","modified":1536943110819},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1536943110843},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1536943110843},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1536943110844},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1536943110844},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1536943110844},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1536943110844},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1536943110844},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1536943110850},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1536943110850},{"_id":"themes/yilia/layout/layout.ejs","hash":"aff13ec451ff0f98b9c2bc9d0e8eae8815cdd7fe","modified":1536987493868},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1536943110850},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1536943110850},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1536943110850},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1536943110851},{"_id":"themes/yilia/source/main.234bc0.css","hash":"0b505e2d152f71ae1c9c201f9a25c28c39d8f6d0","modified":1536943110866},{"_id":"themes/yilia/source/mobile.d238ee.js","hash":"a054884092af1cc5c2c14e5e11a4dac6d9254481","modified":1536943110867},{"_id":"themes/yilia/source/slider.885efe.js","hash":"850271f829a57f60385a9807195965dcfdf4dfb6","modified":1536943110867},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1536943110852},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1536943110863},{"_id":"themes/yilia/source/main.234bc0.js","hash":"988c141a741441812bcf4c408ef530d7a01522f3","modified":1536943110866},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"143710485f734c5a997e0b1c26192bbba2982bcc","modified":1536943110845},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1536943110845},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1536943110845},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"f3a12bbf018d8fe315bb4d65aafcc527d856ca0d","modified":1536984922337},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"0a8d92408bec008763bf141bd578d2d5de0f206c","modified":1536943110845},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"1b91850e8708ce4c83e3cc3f474921182d792308","modified":1536943110846},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"3c137e95ef522be218d5652af8b648b47ddd6ab4","modified":1536943110846},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1536943110846},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1536943110846},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1536943110846},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"daf2b84ba0702c31e16fa33f3af3e941cde3614e","modified":1536943110846},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1536943110847},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1536943110847},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"c4a0f16d554e7e7007856d45b78443d7bf0b40b7","modified":1536943110849},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"41f4ee967a6fafd91282d588026740a5be025da9","modified":1536943110849},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1536943110849},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1536943110863},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1536943110863},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1536943110864},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1536943110864},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1536943110864},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"a5e9fe67e0604c24279281d9fdd2ce1f4536d3e5","modified":1536943110865},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1536943110865},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1536943110865},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1536943110865},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1536943110852},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1536943110852},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"b750499d5120f963b683d0c96ac3f345c714e448","modified":1536943110852},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"ff0a759a40c1f4791f65c182b0a79f80df8e03d3","modified":1536943110852},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"ec90aeba6e05fac8a04e1a444257e1cf9f69fa5c","modified":1536987792869},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"b68772aa2b47d0ed89ce95d4e9d3d27931fe885c","modified":1536943110853},{"_id":"themes/yilia/source-src/css/article.scss","hash":"68efccbcff6162f54e1822764c8c722414f04edf","modified":1536987806869},{"_id":"themes/yilia/source-src/css/duoshuo.scss","hash":"5e3feefbbba70d8da0ec2c75db41762dd4762a81","modified":1536943110855},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"3f5808a49a7365e3f813f78ba96b692f7ca27886","modified":1536943110855},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1536943110856},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1536943110856},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1536943110856},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1536943110857},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0ce6345a86c44e3fea5a4aa439614541112538f3","modified":1536943110857},{"_id":"themes/yilia/source-src/css/main.scss","hash":"40c055e8360973a75db7c13f3280a4f465f9e5e3","modified":1536943110858},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1536943110858},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"12abb65289eed5391d657b963a20f96a473b1cbd","modified":1536943110858},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1536943110858},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1536943110858},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1536943110859},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1536943110859},{"_id":"themes/yilia/source-src/css/social.scss","hash":"b5324302815491d0a5e63142f1ead2048ad3f72f","modified":1536943110859},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1536943110859},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"61917c928d09783a3bc8a91503a59ab3a8696e90","modified":1536943110860},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1536943110859},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1536943110860},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1536943110860},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1536943110861},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1536943110861},{"_id":"themes/yilia/source-src/js/fix.js","hash":"17be4f27eb8951835c29dafd0f6ba1b18e47cc6b","modified":1536943110861},{"_id":"themes/yilia/source-src/js/main.js","hash":"d665f4cf30450984591bc8ad2348a1baf720d04b","modified":1536943110861},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1536943110861},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1536943110861},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1536943110862},{"_id":"themes/yilia/source-src/js/slider.js","hash":"3bf0d70ae171404a0dc73c33ec48927fc2521a54","modified":1536943110862},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1536943110862},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"808a2e1ed407984cfdc929b827d3638f70ec9a2a","modified":1536943110863},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"c2dccf1a95ec09ceeee5004293ac7edb7e1c9a66","modified":1536943110847},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1536943110847},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"57018a5825aca8d277b161ed0990dd9c5a031cc0","modified":1536943110848},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"9201b2e86d697959baa7c923e14dac72d37d37ca","modified":1536943110848},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1536943110848},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1536943110848},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1536943110848},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1536943110849},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1536943110853},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1536943110854},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1536943110854},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1536943110854},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1536943110854},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1536943110855},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1536943110856},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1536943110856},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1536943110856},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1536943110857},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1536943110857},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"a5e9fe67e0604c24279281d9fdd2ce1f4536d3e5","modified":1536943110857}],"Category":[{"name":"front","_id":"cjm28whm500027rs6p8787oej"}],"Data":[],"Page":[],"Post":[{"title":"hexo+github+AppVeyor实现不同电脑写博客","date":"2017-04-06T09:32:14.000Z","_content":"## hexo + github 部分\n+ 以前一直用的像[博客园](http://www.cnblogs.com/)这样专业的博客网站,但是一直想有个个人站点,正好github提供这样的类似功能,并且发现hexo这样的好工具.hexo使用markdown写文章,并且支持github部署.这就很完美了.\n+ 如何使用,网上已有好多教程,不再赘言.\n+ 美中不足的是:换了电脑或者电脑坏了,源文件丢失,就得重新写,非常的麻烦.\n+ 网上也有很多解决方式,我比较喜欢在github备份源文件,并且使用AppVeyor实现自动部署,不用在本地产生文件,也不用即备份又要部署那么繁琐.\n+ 我是学习这篇教程做的,[Hexo的版本控制与持续集成](https://formulahendry.github.io/2016/12/04/hexo-ci/),以下也是我根据其做的实践.\n<!-- more -->\n\n## AppVeyor持续集成\n我是在今年被问到CI,才知道持续集成这个东东的.也没有有机会实践,所以只能跟着教程一步一步操作.\n\n1. 新建两个github仓库,一个是 [killerlei.github.io.](https://github.com/killerlei/killerlei.github.io)(以我的为例) ,另一个是便是备份源文件的仓库 [hexo-github-source](https://github.com/killerlei/hexo-github-source)(以我的为例).\n\n\n2. 注册[APPVeyor](https://www.appveyor.com/),支持github登录,然后新建项目,直接选择github里面的源文件仓库[hexo-github-source](https://github.com/killerlei/hexo-github-source) \n![](http://oo0zdjapt.bkt.clouddn.com/hexo/imagesappveyor-p.png)\n\n3. 在该项目的settings中设置Envirommemt\n![](http://oo0zdjapt.bkt.clouddn.com/Appveyor-e.png)\n\n4. 在源文件根目录中添加appveyor.yml配置文件,我的如下 \n```\nclone_depth: 5\nenvironment:\n  access_token:\n    secure: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(这里需要自己的)\ninstall:\n  - node --version\n  - npm --version\n  - npm install\n  - npm install hexo-cli -g\nbuild_script:\n  - hexo generate\nartifacts:\n  - path: public\n  on_success:\n  - git config --global credential.helper store\n  - ps: Add-Content \"$env:USERPROFILE\\.git-credentials\" \"https://$($env:access_token):x-oauth-basic@github.com`n\"\n  - git config --global user.email \"%GIT_USER_EMAIL%\"\n  - git config --global user.name \"%GIT_USER_NAME%\"\n  - git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site\n  - cd %TEMP%\\static-site\n  - del * /f /q\n  - for /d %%p IN (*) do rmdir \"%%p\" /s /q\n  - SETLOCAL EnableDelayedExpansion & robocopy \"%APPVEYOR_BUILD_FOLDER%\\public\" \"%TEMP%\\static-site\" /e & IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1))\n  - git add -A\n  - if \"%APPVEYOR_REPO_BRANCH%\"==\"master\" if not defined APPVEYOR_PULL_REQUEST_NUMBER (git diff --quiet --exit-code --cached || git commit -m \"Update Static Site\" && git push origin %TARGET_BRANCH% && appveyor AddMessage \"Static Site Updated\")\n```\n5. 第4步需要个人的secure,先到github新建 [Personal access tokens](https://github.com/settings/tokens),然后到AppVeyor加密[AppVeyor加密](https://ci.appveyor.com/tools/encrypt),然后写到第4步里\n\n6. 现在就可以在本地写文章了,比如 <br>新建一篇文章  \n>hexo new \"hexo使用总结\"<br> \n  hexo s   (在本地浏览器检查正常)<br>\n  git push origin master (推送到源文件备份仓库)<br>\n\n   现在AppVeor就开始自动构建.\n![](http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b1.png)\n![](http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b2.png) \n\n成功后就会把生成的文件推送到[killerlei.github.io.](https://github.com/killerlei/killerlei.github.io)仓库\n\n![](http://oo0zdjapt.bkt.clouddn.com/hexo/images/git-io.png)    \n\n就可以在[killerlei.github.io.](https://killerlei.github.io./)访问到新建的文章.\n\n####  这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.\nps:如果使用了hexo的非默认主题,可能会遇到这样的情况(比如我用的yilia主题):<br>\n向源文件仓库push时,会失败,我在网上查了以下,好像是主题文件含有.git文件,本来受git控制,所以会冲突.需要删除.git. 我弄了好久才糊里糊涂弄好.如需帮助,请看[.git解决1](http://memory.blog.51cto.com/6054201/1217107)和[.git解决2](http://bbs.csdn.net/topics/390822726)\n\n//更新 2017-10-14\n\n使用持续集成,本地开发预览完整,但是线上会有问题,会遇到文章列表没有,提示 模块缺失,要安装 hexo-generator-json-content.\n这个问题其实是nodejs 版本低,APPVeyor默认的是version4,要设置builde选项中Platform为x86,并在appveyor.yml中设置\n\n```environment:\n  nodejs_version: \"6\"\n  access_token:\n    secure: DO1FA80B0MgslEfR6NntOIORHAtFOrzO70MvNfZK3OIHpXrundrrSBSx+nEkgx9m\n\n\ninstall:\n # Get the latest stable version of Node.js or io.js\n  - ps: Install-Product node $env:nodejs_version\n  # install modules\n  - npm install\n  - node --version\n  - npm --version\n  - npm install\n  - npm install hexo-cli -g\n\n  ```\n\n这样就ok了,会升级nodejs.","source":"_posts/hexo-github-AppVeyor实现不同电脑写博客.md","raw":"---\ntitle: hexo+github+AppVeyor实现不同电脑写博客\ndate: 2017-04-06 17:32:14\ntags:  [hexo, AppVeyor, 持续集成]\ncategories: [front]\n---\n## hexo + github 部分\n+ 以前一直用的像[博客园](http://www.cnblogs.com/)这样专业的博客网站,但是一直想有个个人站点,正好github提供这样的类似功能,并且发现hexo这样的好工具.hexo使用markdown写文章,并且支持github部署.这就很完美了.\n+ 如何使用,网上已有好多教程,不再赘言.\n+ 美中不足的是:换了电脑或者电脑坏了,源文件丢失,就得重新写,非常的麻烦.\n+ 网上也有很多解决方式,我比较喜欢在github备份源文件,并且使用AppVeyor实现自动部署,不用在本地产生文件,也不用即备份又要部署那么繁琐.\n+ 我是学习这篇教程做的,[Hexo的版本控制与持续集成](https://formulahendry.github.io/2016/12/04/hexo-ci/),以下也是我根据其做的实践.\n<!-- more -->\n\n## AppVeyor持续集成\n我是在今年被问到CI,才知道持续集成这个东东的.也没有有机会实践,所以只能跟着教程一步一步操作.\n\n1. 新建两个github仓库,一个是 [killerlei.github.io.](https://github.com/killerlei/killerlei.github.io)(以我的为例) ,另一个是便是备份源文件的仓库 [hexo-github-source](https://github.com/killerlei/hexo-github-source)(以我的为例).\n\n\n2. 注册[APPVeyor](https://www.appveyor.com/),支持github登录,然后新建项目,直接选择github里面的源文件仓库[hexo-github-source](https://github.com/killerlei/hexo-github-source) \n![](http://oo0zdjapt.bkt.clouddn.com/hexo/imagesappveyor-p.png)\n\n3. 在该项目的settings中设置Envirommemt\n![](http://oo0zdjapt.bkt.clouddn.com/Appveyor-e.png)\n\n4. 在源文件根目录中添加appveyor.yml配置文件,我的如下 \n```\nclone_depth: 5\nenvironment:\n  access_token:\n    secure: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(这里需要自己的)\ninstall:\n  - node --version\n  - npm --version\n  - npm install\n  - npm install hexo-cli -g\nbuild_script:\n  - hexo generate\nartifacts:\n  - path: public\n  on_success:\n  - git config --global credential.helper store\n  - ps: Add-Content \"$env:USERPROFILE\\.git-credentials\" \"https://$($env:access_token):x-oauth-basic@github.com`n\"\n  - git config --global user.email \"%GIT_USER_EMAIL%\"\n  - git config --global user.name \"%GIT_USER_NAME%\"\n  - git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site\n  - cd %TEMP%\\static-site\n  - del * /f /q\n  - for /d %%p IN (*) do rmdir \"%%p\" /s /q\n  - SETLOCAL EnableDelayedExpansion & robocopy \"%APPVEYOR_BUILD_FOLDER%\\public\" \"%TEMP%\\static-site\" /e & IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1))\n  - git add -A\n  - if \"%APPVEYOR_REPO_BRANCH%\"==\"master\" if not defined APPVEYOR_PULL_REQUEST_NUMBER (git diff --quiet --exit-code --cached || git commit -m \"Update Static Site\" && git push origin %TARGET_BRANCH% && appveyor AddMessage \"Static Site Updated\")\n```\n5. 第4步需要个人的secure,先到github新建 [Personal access tokens](https://github.com/settings/tokens),然后到AppVeyor加密[AppVeyor加密](https://ci.appveyor.com/tools/encrypt),然后写到第4步里\n\n6. 现在就可以在本地写文章了,比如 <br>新建一篇文章  \n>hexo new \"hexo使用总结\"<br> \n  hexo s   (在本地浏览器检查正常)<br>\n  git push origin master (推送到源文件备份仓库)<br>\n\n   现在AppVeor就开始自动构建.\n![](http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b1.png)\n![](http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b2.png) \n\n成功后就会把生成的文件推送到[killerlei.github.io.](https://github.com/killerlei/killerlei.github.io)仓库\n\n![](http://oo0zdjapt.bkt.clouddn.com/hexo/images/git-io.png)    \n\n就可以在[killerlei.github.io.](https://killerlei.github.io./)访问到新建的文章.\n\n####  这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.\nps:如果使用了hexo的非默认主题,可能会遇到这样的情况(比如我用的yilia主题):<br>\n向源文件仓库push时,会失败,我在网上查了以下,好像是主题文件含有.git文件,本来受git控制,所以会冲突.需要删除.git. 我弄了好久才糊里糊涂弄好.如需帮助,请看[.git解决1](http://memory.blog.51cto.com/6054201/1217107)和[.git解决2](http://bbs.csdn.net/topics/390822726)\n\n//更新 2017-10-14\n\n使用持续集成,本地开发预览完整,但是线上会有问题,会遇到文章列表没有,提示 模块缺失,要安装 hexo-generator-json-content.\n这个问题其实是nodejs 版本低,APPVeyor默认的是version4,要设置builde选项中Platform为x86,并在appveyor.yml中设置\n\n```environment:\n  nodejs_version: \"6\"\n  access_token:\n    secure: DO1FA80B0MgslEfR6NntOIORHAtFOrzO70MvNfZK3OIHpXrundrrSBSx+nEkgx9m\n\n\ninstall:\n # Get the latest stable version of Node.js or io.js\n  - ps: Install-Product node $env:nodejs_version\n  # install modules\n  - npm install\n  - node --version\n  - npm --version\n  - npm install\n  - npm install hexo-cli -g\n\n  ```\n\n这样就ok了,会升级nodejs.","slug":"hexo-github-AppVeyor实现不同电脑写博客","published":1,"updated":"2018-09-14T16:38:30.817Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm28whly00007rs6b5dhg131","content":"<h2 id=\"hexo-github-部分\"><a href=\"#hexo-github-部分\" class=\"headerlink\" title=\"hexo + github 部分\"></a>hexo + github 部分</h2><ul>\n<li>以前一直用的像<a href=\"http://www.cnblogs.com/\" target=\"_blank\" rel=\"noopener\">博客园</a>这样专业的博客网站,但是一直想有个个人站点,正好github提供这样的类似功能,并且发现hexo这样的好工具.hexo使用markdown写文章,并且支持github部署.这就很完美了.</li>\n<li>如何使用,网上已有好多教程,不再赘言.</li>\n<li>美中不足的是:换了电脑或者电脑坏了,源文件丢失,就得重新写,非常的麻烦.</li>\n<li>网上也有很多解决方式,我比较喜欢在github备份源文件,并且使用AppVeyor实现自动部署,不用在本地产生文件,也不用即备份又要部署那么繁琐.</li>\n<li>我是学习这篇教程做的,<a href=\"https://formulahendry.github.io/2016/12/04/hexo-ci/\" target=\"_blank\" rel=\"noopener\">Hexo的版本控制与持续集成</a>,以下也是我根据其做的实践.<a id=\"more\"></a>\n</li>\n</ul>\n<h2 id=\"AppVeyor持续集成\"><a href=\"#AppVeyor持续集成\" class=\"headerlink\" title=\"AppVeyor持续集成\"></a>AppVeyor持续集成</h2><p>我是在今年被问到CI,才知道持续集成这个东东的.也没有有机会实践,所以只能跟着教程一步一步操作.</p>\n<ol>\n<li>新建两个github仓库,一个是 <a href=\"https://github.com/killerlei/killerlei.github.io\" target=\"_blank\" rel=\"noopener\">killerlei.github.io.</a>(以我的为例) ,另一个是便是备份源文件的仓库 <a href=\"https://github.com/killerlei/hexo-github-source\" target=\"_blank\" rel=\"noopener\">hexo-github-source</a>(以我的为例).</li>\n</ol>\n<ol start=\"2\">\n<li><p>注册<a href=\"https://www.appveyor.com/\" target=\"_blank\" rel=\"noopener\">APPVeyor</a>,支持github登录,然后新建项目,直接选择github里面的源文件仓库<a href=\"https://github.com/killerlei/hexo-github-source\" target=\"_blank\" rel=\"noopener\">hexo-github-source</a><br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/imagesappveyor-p.png\" alt=\"\"></p>\n</li>\n<li><p>在该项目的settings中设置Envirommemt<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/Appveyor-e.png\" alt=\"\"></p>\n</li>\n<li><p>在源文件根目录中添加appveyor.yml配置文件,我的如下 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clone_depth: 5</span><br><span class=\"line\">environment:</span><br><span class=\"line\">  access_token:</span><br><span class=\"line\">    secure: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(这里需要自己的)</span><br><span class=\"line\">install:</span><br><span class=\"line\">  - node --version</span><br><span class=\"line\">  - npm --version</span><br><span class=\"line\">  - npm install</span><br><span class=\"line\">  - npm install hexo-cli -g</span><br><span class=\"line\">build_script:</span><br><span class=\"line\">  - hexo generate</span><br><span class=\"line\">artifacts:</span><br><span class=\"line\">  - path: public</span><br><span class=\"line\">  on_success:</span><br><span class=\"line\">  - git config --global credential.helper store</span><br><span class=\"line\">  - ps: Add-Content &quot;$env:USERPROFILE\\.git-credentials&quot; &quot;https://$($env:access_token):x-oauth-basic@github.com`n&quot;</span><br><span class=\"line\">  - git config --global user.email &quot;%GIT_USER_EMAIL%&quot;</span><br><span class=\"line\">  - git config --global user.name &quot;%GIT_USER_NAME%&quot;</span><br><span class=\"line\">  - git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site</span><br><span class=\"line\">  - cd %TEMP%\\static-site</span><br><span class=\"line\">  - del * /f /q</span><br><span class=\"line\">  - for /d %%p IN (*) do rmdir &quot;%%p&quot; /s /q</span><br><span class=\"line\">  - SETLOCAL EnableDelayedExpansion &amp; robocopy &quot;%APPVEYOR_BUILD_FOLDER%\\public&quot; &quot;%TEMP%\\static-site&quot; /e &amp; IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1))</span><br><span class=\"line\">  - git add -A</span><br><span class=\"line\">  - if &quot;%APPVEYOR_REPO_BRANCH%&quot;==&quot;master&quot; if not defined APPVEYOR_PULL_REQUEST_NUMBER (git diff --quiet --exit-code --cached || git commit -m &quot;Update Static Site&quot; &amp;&amp; git push origin %TARGET_BRANCH% &amp;&amp; appveyor AddMessage &quot;Static Site Updated&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第4步需要个人的secure,先到github新建 <a href=\"https://github.com/settings/tokens\" target=\"_blank\" rel=\"noopener\">Personal access tokens</a>,然后到AppVeyor加密<a href=\"https://ci.appveyor.com/tools/encrypt\" target=\"_blank\" rel=\"noopener\">AppVeyor加密</a>,然后写到第4步里</p>\n</li>\n<li><p>现在就可以在本地写文章了,比如 <br>新建一篇文章  </p>\n<blockquote>\n<p>hexo new “hexo使用总结”<br><br>hexo s   (在本地浏览器检查正常)<br><br>git push origin master (推送到源文件备份仓库)<br></p>\n</blockquote>\n<p>现在AppVeor就开始自动构建.<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b1.png\" alt=\"\"><br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b2.png\" alt=\"\"> </p>\n</li>\n</ol>\n<p>成功后就会把生成的文件推送到<a href=\"https://github.com/killerlei/killerlei.github.io\" target=\"_blank\" rel=\"noopener\">killerlei.github.io.</a>仓库</p>\n<p><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/images/git-io.png\" alt=\"\">    </p>\n<p>就可以在<a href=\"https://killerlei.github.io./\" target=\"_blank\" rel=\"noopener\">killerlei.github.io.</a>访问到新建的文章.</p>\n<h4 id=\"这样是不是很方便-换个电脑直接从源文件仓库clone下来-也不怕丢失\"><a href=\"#这样是不是很方便-换个电脑直接从源文件仓库clone下来-也不怕丢失\" class=\"headerlink\" title=\"这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.\"></a>这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.</h4><p>ps:如果使用了hexo的非默认主题,可能会遇到这样的情况(比如我用的yilia主题):<br><br>向源文件仓库push时,会失败,我在网上查了以下,好像是主题文件含有.git文件,本来受git控制,所以会冲突.需要删除.git. 我弄了好久才糊里糊涂弄好.如需帮助,请看<a href=\"http://memory.blog.51cto.com/6054201/1217107\" target=\"_blank\" rel=\"noopener\">.git解决1</a>和<a href=\"http://bbs.csdn.net/topics/390822726\" target=\"_blank\" rel=\"noopener\">.git解决2</a></p>\n<p>//更新 2017-10-14</p>\n<p>使用持续集成,本地开发预览完整,但是线上会有问题,会遇到文章列表没有,提示 模块缺失,要安装 hexo-generator-json-content.<br>这个问题其实是nodejs 版本低,APPVeyor默认的是version4,要设置builde选项中Platform为x86,并在appveyor.yml中设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  nodejs_version: &quot;6&quot;</span><br><span class=\"line\">  access_token:</span><br><span class=\"line\">    secure: DO1FA80B0MgslEfR6NntOIORHAtFOrzO70MvNfZK3OIHpXrundrrSBSx+nEkgx9m</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">install:</span><br><span class=\"line\"> # Get the latest stable version of Node.js or io.js</span><br><span class=\"line\">  - ps: Install-Product node $env:nodejs_version</span><br><span class=\"line\">  # install modules</span><br><span class=\"line\">  - npm install</span><br><span class=\"line\">  - node --version</span><br><span class=\"line\">  - npm --version</span><br><span class=\"line\">  - npm install</span><br><span class=\"line\">  - npm install hexo-cli -g</span><br></pre></td></tr></table></figure>\n<p>这样就ok了,会升级nodejs.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"hexo-github-部分\"><a href=\"#hexo-github-部分\" class=\"headerlink\" title=\"hexo + github 部分\"></a>hexo + github 部分</h2><ul>\n<li>以前一直用的像<a href=\"http://www.cnblogs.com/\" target=\"_blank\" rel=\"noopener\">博客园</a>这样专业的博客网站,但是一直想有个个人站点,正好github提供这样的类似功能,并且发现hexo这样的好工具.hexo使用markdown写文章,并且支持github部署.这就很完美了.</li>\n<li>如何使用,网上已有好多教程,不再赘言.</li>\n<li>美中不足的是:换了电脑或者电脑坏了,源文件丢失,就得重新写,非常的麻烦.</li>\n<li>网上也有很多解决方式,我比较喜欢在github备份源文件,并且使用AppVeyor实现自动部署,不用在本地产生文件,也不用即备份又要部署那么繁琐.</li>\n<li>我是学习这篇教程做的,<a href=\"https://formulahendry.github.io/2016/12/04/hexo-ci/\" target=\"_blank\" rel=\"noopener\">Hexo的版本控制与持续集成</a>,以下也是我根据其做的实践.","more":"</li>\n</ul>\n<h2 id=\"AppVeyor持续集成\"><a href=\"#AppVeyor持续集成\" class=\"headerlink\" title=\"AppVeyor持续集成\"></a>AppVeyor持续集成</h2><p>我是在今年被问到CI,才知道持续集成这个东东的.也没有有机会实践,所以只能跟着教程一步一步操作.</p>\n<ol>\n<li>新建两个github仓库,一个是 <a href=\"https://github.com/killerlei/killerlei.github.io\" target=\"_blank\" rel=\"noopener\">killerlei.github.io.</a>(以我的为例) ,另一个是便是备份源文件的仓库 <a href=\"https://github.com/killerlei/hexo-github-source\" target=\"_blank\" rel=\"noopener\">hexo-github-source</a>(以我的为例).</li>\n</ol>\n<ol start=\"2\">\n<li><p>注册<a href=\"https://www.appveyor.com/\" target=\"_blank\" rel=\"noopener\">APPVeyor</a>,支持github登录,然后新建项目,直接选择github里面的源文件仓库<a href=\"https://github.com/killerlei/hexo-github-source\" target=\"_blank\" rel=\"noopener\">hexo-github-source</a><br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/imagesappveyor-p.png\" alt=\"\"></p>\n</li>\n<li><p>在该项目的settings中设置Envirommemt<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/Appveyor-e.png\" alt=\"\"></p>\n</li>\n<li><p>在源文件根目录中添加appveyor.yml配置文件,我的如下 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clone_depth: 5</span><br><span class=\"line\">environment:</span><br><span class=\"line\">  access_token:</span><br><span class=\"line\">    secure: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(这里需要自己的)</span><br><span class=\"line\">install:</span><br><span class=\"line\">  - node --version</span><br><span class=\"line\">  - npm --version</span><br><span class=\"line\">  - npm install</span><br><span class=\"line\">  - npm install hexo-cli -g</span><br><span class=\"line\">build_script:</span><br><span class=\"line\">  - hexo generate</span><br><span class=\"line\">artifacts:</span><br><span class=\"line\">  - path: public</span><br><span class=\"line\">  on_success:</span><br><span class=\"line\">  - git config --global credential.helper store</span><br><span class=\"line\">  - ps: Add-Content &quot;$env:USERPROFILE\\.git-credentials&quot; &quot;https://$($env:access_token):x-oauth-basic@github.com`n&quot;</span><br><span class=\"line\">  - git config --global user.email &quot;%GIT_USER_EMAIL%&quot;</span><br><span class=\"line\">  - git config --global user.name &quot;%GIT_USER_NAME%&quot;</span><br><span class=\"line\">  - git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site</span><br><span class=\"line\">  - cd %TEMP%\\static-site</span><br><span class=\"line\">  - del * /f /q</span><br><span class=\"line\">  - for /d %%p IN (*) do rmdir &quot;%%p&quot; /s /q</span><br><span class=\"line\">  - SETLOCAL EnableDelayedExpansion &amp; robocopy &quot;%APPVEYOR_BUILD_FOLDER%\\public&quot; &quot;%TEMP%\\static-site&quot; /e &amp; IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1))</span><br><span class=\"line\">  - git add -A</span><br><span class=\"line\">  - if &quot;%APPVEYOR_REPO_BRANCH%&quot;==&quot;master&quot; if not defined APPVEYOR_PULL_REQUEST_NUMBER (git diff --quiet --exit-code --cached || git commit -m &quot;Update Static Site&quot; &amp;&amp; git push origin %TARGET_BRANCH% &amp;&amp; appveyor AddMessage &quot;Static Site Updated&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第4步需要个人的secure,先到github新建 <a href=\"https://github.com/settings/tokens\" target=\"_blank\" rel=\"noopener\">Personal access tokens</a>,然后到AppVeyor加密<a href=\"https://ci.appveyor.com/tools/encrypt\" target=\"_blank\" rel=\"noopener\">AppVeyor加密</a>,然后写到第4步里</p>\n</li>\n<li><p>现在就可以在本地写文章了,比如 <br>新建一篇文章  </p>\n<blockquote>\n<p>hexo new “hexo使用总结”<br><br>hexo s   (在本地浏览器检查正常)<br><br>git push origin master (推送到源文件备份仓库)<br></p>\n</blockquote>\n<p>现在AppVeor就开始自动构建.<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b1.png\" alt=\"\"><br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b2.png\" alt=\"\"> </p>\n</li>\n</ol>\n<p>成功后就会把生成的文件推送到<a href=\"https://github.com/killerlei/killerlei.github.io\" target=\"_blank\" rel=\"noopener\">killerlei.github.io.</a>仓库</p>\n<p><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/images/git-io.png\" alt=\"\">    </p>\n<p>就可以在<a href=\"https://killerlei.github.io./\" target=\"_blank\" rel=\"noopener\">killerlei.github.io.</a>访问到新建的文章.</p>\n<h4 id=\"这样是不是很方便-换个电脑直接从源文件仓库clone下来-也不怕丢失\"><a href=\"#这样是不是很方便-换个电脑直接从源文件仓库clone下来-也不怕丢失\" class=\"headerlink\" title=\"这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.\"></a>这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.</h4><p>ps:如果使用了hexo的非默认主题,可能会遇到这样的情况(比如我用的yilia主题):<br><br>向源文件仓库push时,会失败,我在网上查了以下,好像是主题文件含有.git文件,本来受git控制,所以会冲突.需要删除.git. 我弄了好久才糊里糊涂弄好.如需帮助,请看<a href=\"http://memory.blog.51cto.com/6054201/1217107\" target=\"_blank\" rel=\"noopener\">.git解决1</a>和<a href=\"http://bbs.csdn.net/topics/390822726\" target=\"_blank\" rel=\"noopener\">.git解决2</a></p>\n<p>//更新 2017-10-14</p>\n<p>使用持续集成,本地开发预览完整,但是线上会有问题,会遇到文章列表没有,提示 模块缺失,要安装 hexo-generator-json-content.<br>这个问题其实是nodejs 版本低,APPVeyor默认的是version4,要设置builde选项中Platform为x86,并在appveyor.yml中设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  nodejs_version: &quot;6&quot;</span><br><span class=\"line\">  access_token:</span><br><span class=\"line\">    secure: DO1FA80B0MgslEfR6NntOIORHAtFOrzO70MvNfZK3OIHpXrundrrSBSx+nEkgx9m</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">install:</span><br><span class=\"line\"> # Get the latest stable version of Node.js or io.js</span><br><span class=\"line\">  - ps: Install-Product node $env:nodejs_version</span><br><span class=\"line\">  # install modules</span><br><span class=\"line\">  - npm install</span><br><span class=\"line\">  - node --version</span><br><span class=\"line\">  - npm --version</span><br><span class=\"line\">  - npm install</span><br><span class=\"line\">  - npm install hexo-cli -g</span><br></pre></td></tr></table></figure>\n<p>这样就ok了,会升级nodejs.</p>"},{"title":"jsonp使用及promise封装","date":"2017-10-05T03:38:12.000Z","_content":"\n1 .\n[jsonp](https://github.com/webmodules/jsonp)简单封装了跨域请求方法jsonp,利用script标签不受同源策略的限制,达到ajax的效果.\n\n2 .\n\n        jsonp(url, opts, fn)\n\n        url (String) url to fetch\n        opts (Object), optional\n            param (String) name of the query string parameter to specify the callback (defaults to callback)\n            timeout (Number) how long after a timeout error is emitted. 0 to disable (defaults to 60000)\n            prefix (String) prefix for the global callback functions that handle jsonp responses (defaults to __jp)\n            name (String) name of the global callback functions that handle jsonp responses (defaults to prefix + incremented counter)\n        fn callback\n            The callback is called with err, data parameters.\n\n        If it times out, the err will be an Error object whose message is Timeout.\n\n        Returns a function that, when called, will cancel the in-progress jsonp request (fn won't be called).\n\n    opts 中里面属性都有默认值,可以不用设置,但是注意param是前后端协议好的请求字段,默认值为callback,后端要根据这个字段拿到函数名,也就是另一个属性name,即jsonp原理中js中已经定义好的函数(jsonp内部会分配给全局对象对应属性,有name则是name值,如果没有则会根据prefix自动分配,并赋值fn).\n<!-- more -->\n\n3.这种用回调函数异步编程的方式可以利用ES6的promise实现同步编程,更加直观.\n    举例来讲\n\n    //构造函数接受两个参数,分别代表已完成/未完成两种状态变化,返回一各实例,可以在其then方法里传入成功时处理函数和失败时处理函数\n\n        var promise = new Promise(function(resolve,reject){\n                异步操作代码......\n                resolve(value)\n                reject(error)\n        }\n        promise.then(function(value){......},function(err){....})\n\n4.利用promise改造jsonp\n\n    import originJSONP from 'jsonp'\n    export default function jsonp(url, data, option) {\n      url += (url.indexOf('?') < 0 ? '?' : '&') + param(data)\n      return new Promise((resolve, reject) => {\n        originJSONP(url, option, (err, data) => {\n          if (!err) {\n            resolve(data)\n          } else {\n            reject(err)\n          }\n        })\n      })\n    }\n    function param(data) {\n      let url = ''\n      for (var k in data) {\n        let value = data[k] !== undefined ? data[k] : ''\n        url += `&${k}=${encodeURIComponent(value)}`\n      }\n      return url ? url.substring(1) : ''\n    }\n\n5.使用(在vue中使用)\n\n    import jsonp from './xxxxx'\n\n    data(){\n        return {\n            data:''\n        }\n    },\n    methods:{\n        getData(){\n            let url='**********'\n            let data = {xxxxxxx:xxxxx}\n            let option = {xxxxx:xxxxx}\n            jsonp(url,data,option).then((res) => {\n                 if (res.code === 0) {\n                    this.data = res.data.list\n                 }\n            })\n        }\n    }\n","source":"_posts/jsonp使用及promise封装.md","raw":"---\ntitle: jsonp使用及promise封装\ndate: 2017-10-05 11:38:12\ntags: [跨域, jsonp, promise, 异步同步]\ncategories: [front]\n---\n\n1 .\n[jsonp](https://github.com/webmodules/jsonp)简单封装了跨域请求方法jsonp,利用script标签不受同源策略的限制,达到ajax的效果.\n\n2 .\n\n        jsonp(url, opts, fn)\n\n        url (String) url to fetch\n        opts (Object), optional\n            param (String) name of the query string parameter to specify the callback (defaults to callback)\n            timeout (Number) how long after a timeout error is emitted. 0 to disable (defaults to 60000)\n            prefix (String) prefix for the global callback functions that handle jsonp responses (defaults to __jp)\n            name (String) name of the global callback functions that handle jsonp responses (defaults to prefix + incremented counter)\n        fn callback\n            The callback is called with err, data parameters.\n\n        If it times out, the err will be an Error object whose message is Timeout.\n\n        Returns a function that, when called, will cancel the in-progress jsonp request (fn won't be called).\n\n    opts 中里面属性都有默认值,可以不用设置,但是注意param是前后端协议好的请求字段,默认值为callback,后端要根据这个字段拿到函数名,也就是另一个属性name,即jsonp原理中js中已经定义好的函数(jsonp内部会分配给全局对象对应属性,有name则是name值,如果没有则会根据prefix自动分配,并赋值fn).\n<!-- more -->\n\n3.这种用回调函数异步编程的方式可以利用ES6的promise实现同步编程,更加直观.\n    举例来讲\n\n    //构造函数接受两个参数,分别代表已完成/未完成两种状态变化,返回一各实例,可以在其then方法里传入成功时处理函数和失败时处理函数\n\n        var promise = new Promise(function(resolve,reject){\n                异步操作代码......\n                resolve(value)\n                reject(error)\n        }\n        promise.then(function(value){......},function(err){....})\n\n4.利用promise改造jsonp\n\n    import originJSONP from 'jsonp'\n    export default function jsonp(url, data, option) {\n      url += (url.indexOf('?') < 0 ? '?' : '&') + param(data)\n      return new Promise((resolve, reject) => {\n        originJSONP(url, option, (err, data) => {\n          if (!err) {\n            resolve(data)\n          } else {\n            reject(err)\n          }\n        })\n      })\n    }\n    function param(data) {\n      let url = ''\n      for (var k in data) {\n        let value = data[k] !== undefined ? data[k] : ''\n        url += `&${k}=${encodeURIComponent(value)}`\n      }\n      return url ? url.substring(1) : ''\n    }\n\n5.使用(在vue中使用)\n\n    import jsonp from './xxxxx'\n\n    data(){\n        return {\n            data:''\n        }\n    },\n    methods:{\n        getData(){\n            let url='**********'\n            let data = {xxxxxxx:xxxxx}\n            let option = {xxxxx:xxxxx}\n            jsonp(url,data,option).then((res) => {\n                 if (res.code === 0) {\n                    this.data = res.data.list\n                 }\n            })\n        }\n    }\n","slug":"jsonp使用及promise封装","published":1,"updated":"2018-09-14T16:38:30.818Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm28whm200017rs69ommqq69","content":"<p>1 .<br><a href=\"https://github.com/webmodules/jsonp\" target=\"_blank\" rel=\"noopener\">jsonp</a>简单封装了跨域请求方法jsonp,利用script标签不受同源策略的限制,达到ajax的效果.</p>\n<p>2 .</p>\n<pre><code>    jsonp(url, opts, fn)\n\n    url (String) url to fetch\n    opts (Object), optional\n        param (String) name of the query string parameter to specify the callback (defaults to callback)\n        timeout (Number) how long after a timeout error is emitted. 0 to disable (defaults to 60000)\n        prefix (String) prefix for the global callback functions that handle jsonp responses (defaults to __jp)\n        name (String) name of the global callback functions that handle jsonp responses (defaults to prefix + incremented counter)\n    fn callback\n        The callback is called with err, data parameters.\n\n    If it times out, the err will be an Error object whose message is Timeout.\n\n    Returns a function that, when called, will cancel the in-progress jsonp request (fn won&apos;t be called).\n\nopts 中里面属性都有默认值,可以不用设置,但是注意param是前后端协议好的请求字段,默认值为callback,后端要根据这个字段拿到函数名,也就是另一个属性name,即jsonp原理中js中已经定义好的函数(jsonp内部会分配给全局对象对应属性,有name则是name值,如果没有则会根据prefix自动分配,并赋值fn).\n</code></pre><a id=\"more\"></a>\n<p>3.这种用回调函数异步编程的方式可以利用ES6的promise实现同步编程,更加直观.<br>    举例来讲</p>\n<pre><code>//构造函数接受两个参数,分别代表已完成/未完成两种状态变化,返回一各实例,可以在其then方法里传入成功时处理函数和失败时处理函数\n\n    var promise = new Promise(function(resolve,reject){\n            异步操作代码......\n            resolve(value)\n            reject(error)\n    }\n    promise.then(function(value){......},function(err){....})\n</code></pre><p>4.利用promise改造jsonp</p>\n<pre><code>import originJSONP from &apos;jsonp&apos;\nexport default function jsonp(url, data, option) {\n  url += (url.indexOf(&apos;?&apos;) &lt; 0 ? &apos;?&apos; : &apos;&amp;&apos;) + param(data)\n  return new Promise((resolve, reject) =&gt; {\n    originJSONP(url, option, (err, data) =&gt; {\n      if (!err) {\n        resolve(data)\n      } else {\n        reject(err)\n      }\n    })\n  })\n}\nfunction param(data) {\n  let url = &apos;&apos;\n  for (var k in data) {\n    let value = data[k] !== undefined ? data[k] : &apos;&apos;\n    url += `&amp;${k}=${encodeURIComponent(value)}`\n  }\n  return url ? url.substring(1) : &apos;&apos;\n}\n</code></pre><p>5.使用(在vue中使用)</p>\n<pre><code>import jsonp from &apos;./xxxxx&apos;\n\ndata(){\n    return {\n        data:&apos;&apos;\n    }\n},\nmethods:{\n    getData(){\n        let url=&apos;**********&apos;\n        let data = {xxxxxxx:xxxxx}\n        let option = {xxxxx:xxxxx}\n        jsonp(url,data,option).then((res) =&gt; {\n             if (res.code === 0) {\n                this.data = res.data.list\n             }\n        })\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"<p>1 .<br><a href=\"https://github.com/webmodules/jsonp\" target=\"_blank\" rel=\"noopener\">jsonp</a>简单封装了跨域请求方法jsonp,利用script标签不受同源策略的限制,达到ajax的效果.</p>\n<p>2 .</p>\n<pre><code>    jsonp(url, opts, fn)\n\n    url (String) url to fetch\n    opts (Object), optional\n        param (String) name of the query string parameter to specify the callback (defaults to callback)\n        timeout (Number) how long after a timeout error is emitted. 0 to disable (defaults to 60000)\n        prefix (String) prefix for the global callback functions that handle jsonp responses (defaults to __jp)\n        name (String) name of the global callback functions that handle jsonp responses (defaults to prefix + incremented counter)\n    fn callback\n        The callback is called with err, data parameters.\n\n    If it times out, the err will be an Error object whose message is Timeout.\n\n    Returns a function that, when called, will cancel the in-progress jsonp request (fn won&apos;t be called).\n\nopts 中里面属性都有默认值,可以不用设置,但是注意param是前后端协议好的请求字段,默认值为callback,后端要根据这个字段拿到函数名,也就是另一个属性name,即jsonp原理中js中已经定义好的函数(jsonp内部会分配给全局对象对应属性,有name则是name值,如果没有则会根据prefix自动分配,并赋值fn).\n</code></pre>","more":"<p>3.这种用回调函数异步编程的方式可以利用ES6的promise实现同步编程,更加直观.<br>    举例来讲</p>\n<pre><code>//构造函数接受两个参数,分别代表已完成/未完成两种状态变化,返回一各实例,可以在其then方法里传入成功时处理函数和失败时处理函数\n\n    var promise = new Promise(function(resolve,reject){\n            异步操作代码......\n            resolve(value)\n            reject(error)\n    }\n    promise.then(function(value){......},function(err){....})\n</code></pre><p>4.利用promise改造jsonp</p>\n<pre><code>import originJSONP from &apos;jsonp&apos;\nexport default function jsonp(url, data, option) {\n  url += (url.indexOf(&apos;?&apos;) &lt; 0 ? &apos;?&apos; : &apos;&amp;&apos;) + param(data)\n  return new Promise((resolve, reject) =&gt; {\n    originJSONP(url, option, (err, data) =&gt; {\n      if (!err) {\n        resolve(data)\n      } else {\n        reject(err)\n      }\n    })\n  })\n}\nfunction param(data) {\n  let url = &apos;&apos;\n  for (var k in data) {\n    let value = data[k] !== undefined ? data[k] : &apos;&apos;\n    url += `&amp;${k}=${encodeURIComponent(value)}`\n  }\n  return url ? url.substring(1) : &apos;&apos;\n}\n</code></pre><p>5.使用(在vue中使用)</p>\n<pre><code>import jsonp from &apos;./xxxxx&apos;\n\ndata(){\n    return {\n        data:&apos;&apos;\n    }\n},\nmethods:{\n    getData(){\n        let url=&apos;**********&apos;\n        let data = {xxxxxxx:xxxxx}\n        let option = {xxxxx:xxxxx}\n        jsonp(url,data,option).then((res) =&gt; {\n             if (res.code === 0) {\n                this.data = res.data.list\n             }\n        })\n    }\n}\n</code></pre>"},{"title":"swiper-animate 冲突解决","date":"2017-04-23T03:39:44.000Z","_content":"# 冲突\n* swiper是个使用广泛，兼容性很高的js插件，可以独立使用，也可以跟jQuery配合使用。\n* swiper-animate是swiper基础上开发的动画插件，可以实现非常酷炫的效果。\n* 这周在写一个页面，里面有轮播图、tab选项卡，用swiper开发非常方便，当然也用到了swiper-animate，\n但是，两个swiper实例之间的 swiper-animate会互相影响，发生动画效果消失或错乱。\n* 在网上也没找到解决办法，最后只能用笨办法了。\n\n<!-- more -->\n\n#解决\n1. 在swiper-animate.jsh中复制三个函数，并分别改名为原名+me，修改querySelectorAll(\".ani\")为querySelectorAll(\".anime\")。\n![11](http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-animate.png)\n2. 在html中把第二个用到动画的标签类名由ani改成animate\n![22](http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-html.png)\n3. 在js中创建实例时候，调用修改过的函数名。\n![33](http://oo0zdjapt.bkt.clouddn.com/hexo-2swper-function.png)\n\n这样就解决了冲突，只是办法太笨了。","source":"_posts/swiper-animal-冲突解决.md","raw":"---\ntitle: swiper-animate 冲突解决\ndate: 2017-04-23 11:39:44\ntags: [swiper-animal] \ncategories: [front]\n---\n# 冲突\n* swiper是个使用广泛，兼容性很高的js插件，可以独立使用，也可以跟jQuery配合使用。\n* swiper-animate是swiper基础上开发的动画插件，可以实现非常酷炫的效果。\n* 这周在写一个页面，里面有轮播图、tab选项卡，用swiper开发非常方便，当然也用到了swiper-animate，\n但是，两个swiper实例之间的 swiper-animate会互相影响，发生动画效果消失或错乱。\n* 在网上也没找到解决办法，最后只能用笨办法了。\n\n<!-- more -->\n\n#解决\n1. 在swiper-animate.jsh中复制三个函数，并分别改名为原名+me，修改querySelectorAll(\".ani\")为querySelectorAll(\".anime\")。\n![11](http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-animate.png)\n2. 在html中把第二个用到动画的标签类名由ani改成animate\n![22](http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-html.png)\n3. 在js中创建实例时候，调用修改过的函数名。\n![33](http://oo0zdjapt.bkt.clouddn.com/hexo-2swper-function.png)\n\n这样就解决了冲突，只是办法太笨了。","slug":"swiper-animal-冲突解决","published":1,"updated":"2018-09-14T16:38:30.818Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm28whm700047rs6ozvlcja1","content":"<h1 id=\"冲突\"><a href=\"#冲突\" class=\"headerlink\" title=\"冲突\"></a>冲突</h1><ul>\n<li>swiper是个使用广泛，兼容性很高的js插件，可以独立使用，也可以跟jQuery配合使用。</li>\n<li>swiper-animate是swiper基础上开发的动画插件，可以实现非常酷炫的效果。</li>\n<li>这周在写一个页面，里面有轮播图、tab选项卡，用swiper开发非常方便，当然也用到了swiper-animate，<br>但是，两个swiper实例之间的 swiper-animate会互相影响，发生动画效果消失或错乱。</li>\n<li>在网上也没找到解决办法，最后只能用笨办法了。</li>\n</ul>\n<a id=\"more\"></a>\n<p>#解决</p>\n<ol>\n<li>在swiper-animate.jsh中复制三个函数，并分别改名为原名+me，修改querySelectorAll(“.ani”)为querySelectorAll(“.anime”)。<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-animate.png\" alt=\"11\"></li>\n<li>在html中把第二个用到动画的标签类名由ani改成animate<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-html.png\" alt=\"22\"></li>\n<li>在js中创建实例时候，调用修改过的函数名。<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo-2swper-function.png\" alt=\"33\"></li>\n</ol>\n<p>这样就解决了冲突，只是办法太笨了。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"冲突\"><a href=\"#冲突\" class=\"headerlink\" title=\"冲突\"></a>冲突</h1><ul>\n<li>swiper是个使用广泛，兼容性很高的js插件，可以独立使用，也可以跟jQuery配合使用。</li>\n<li>swiper-animate是swiper基础上开发的动画插件，可以实现非常酷炫的效果。</li>\n<li>这周在写一个页面，里面有轮播图、tab选项卡，用swiper开发非常方便，当然也用到了swiper-animate，<br>但是，两个swiper实例之间的 swiper-animate会互相影响，发生动画效果消失或错乱。</li>\n<li>在网上也没找到解决办法，最后只能用笨办法了。</li>\n</ul>","more":"<p>#解决</p>\n<ol>\n<li>在swiper-animate.jsh中复制三个函数，并分别改名为原名+me，修改querySelectorAll(“.ani”)为querySelectorAll(“.anime”)。<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-animate.png\" alt=\"11\"></li>\n<li>在html中把第二个用到动画的标签类名由ani改成animate<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-html.png\" alt=\"22\"></li>\n<li>在js中创建实例时候，调用修改过的函数名。<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo-2swper-function.png\" alt=\"33\"></li>\n</ol>\n<p>这样就解决了冲突，只是办法太笨了。</p>"},{"title":"vue-cli-2中webpack的配置分析二","date":"2017-10-08T02:44:20.000Z","_content":"这片也是转载,[叶家伟的博客](http://www.cnblogs.com/ye-hcj/p/7077796.html),这里有一系列的vue-cli中webpack分析文章,可以移步阅读.\n另外还找到另外一片博客[vue-cli的webpack模板项目配置文件分析](http://blog.csdn.net/hongchh/article/details/55113751)\n加上前面滴滴那篇介绍,对比读起来肯定会理解的快.\n总之,网上有已有大量的学习资料,前人栽树,后人乘凉,感谢.\n## config/index.js\n        \n        // see http://vuejs-templates.github.io/webpack for documentation.\n        // path是node.js的路径模块，用来处理路径统一的问题\n        var path = require('path')\n        \n        module.exports = {\n            // 下面是build也就是生产编译环境下的一些配置\n            build: {\n                // 导入prod.env.js配置文件，只要用来指定当前环境，详细见(1)\n                env: require('./prod.env'),\n                // 下面是相对路径的拼接，假如当前跟目录是config，那么下面配置的index属性的属性值就是dist/index.html\n                index: path.resolve(__dirname, '../dist/index.html'),\n                // 下面定义的是静态资源的根目录 也就是dist目录\n                assetsRoot: path.resolve(__dirname, '../dist'),\n                // 下面定义的是静态资源根目录的子目录static，也就是dist目录下面的static\n                assetsSubDirectory: 'static',\n                // 下面定义的是静态资源的公开路径，也就是真正的引用路径\n                assetsPublicPath: '/',\n                // 下面定义是否生成生产环境的sourcmap，sourcmap是用来debug编译后文件的，通过映射到编译前文件来实现\n                productionSourceMap: true,\n                // Gzip off by default as many popular static hosts such as\n                // Surge or Netlify already gzip all static assets for you.\n                // Before setting to `true`, make sure to:\n                // npm install --save-dev compression-webpack-plugin\n                // 下面是是否在生产环境中压缩代码，如果要压缩必须安装compression-webpack-plugin\n                productionGzip: false,\n                // 下面定义要压缩哪些类型的文件\n                productionGzipExtensions: ['js', 'css'],\n                // Run the build command with an extra argument to\n                // View the bundle analyzer report after build finishes:\n                // `npm run build --report`\n                // Set to `true` or `false` to always turn it on or off\n                // 下面是用来开启编译完成后的报告，可以通过设置值为true和false来开启或关闭\n                // 下面的process.env.npm_config_report表示定义的一个npm_config_report环境变量，可以自行设置\n                bundleAnalyzerReport: process.env.npm_config_report\n            },\n            dev: {\n                // 引入当前目录下的dev.env.js，用来指明开发环境，详见(2)\n                env: require('./dev.env'),\n                // 下面是dev-server的端口号，可以自行更改\n                port: 8080,\n                // 下面表示是否自定代开浏览器\n                autoOpenBrowser: true,\n                assetsSubDirectory: 'static',\n                assetsPublicPath: '/',\n                // 下面是代理表，作用是用来，建一个虚拟api服务器用来代理本机的请求，只能用于开发模式\n                // 详见(3)\n                proxyTable: {},\n                // CSS Sourcemaps off by default because relative paths are \"buggy\"\n                // with this option, according to the CSS-Loader README\n                // (https://github.com/webpack/css-loader#sourcemaps)\n                // In our experience, they generally work as expected,\n                // just be aware of this issue when enabling this option.\n                // 是否生成css，map文件，上面这段英文就是说使用这个cssmap可能存在问题，但是按照经验，问题不大，可以使用\n                // 给人觉得没必要用这个，css出了问题，直接控制台不就完事了\n                cssSourceMap: false\n            }\n        }\n<!-- more -->        \n## prod.env.js \n        \n         module.exports = {\n                // 作用很明显，就是导出一个对象，NODE_ENV是一个环境变量，指定production环境\n                NODE_ENV: '\"production\"'\n            }\n\n## dev.env.js\n        \n         // 首先引入的是webpack的merge插件，该插件是用来合并对象，也就是配置文件用的，相同的选项会被覆盖，至于这里为什么多次一举，可能另有他图吧\n            var merge = require('webpack-merge')\n            // 导入prod.env.js配置文件\n            var prodEnv = require('./prod.env')\n            // 将两个配置对象合并，最终结果是 NODE_ENV: '\"development\"'\n            module.exports = merge(prodEnv, {\n                NODE_ENV: '\"development\"'\n            })\n            \n## proxyTable用法\n           \n           vue-cli使用这个功能是借助http-proxy-middleware插件，一般解决跨域请求api\n               proxyTable: {\n                   '/list': {\n                       target: 'http://api.xxxxxxxx.com', -> 目标url地址\n                       changeOrigin: true, -> 指示是否跨域\n                       pathRewrite: {\n                       '^/list': '/list' -> 可以使用 /list 等价于 api.xxxxxxxx.com/list\n                       }\n                   }\n               }\n            \n            ","source":"_posts/vue-cli-2中webpack的配置分析二.md","raw":"---\ntitle: vue-cli-2中webpack的配置分析二\ndate: 2017-10-08 10:44:20\ntags: [webpack,vue-cli] \ncategories: [front]\n---\n这片也是转载,[叶家伟的博客](http://www.cnblogs.com/ye-hcj/p/7077796.html),这里有一系列的vue-cli中webpack分析文章,可以移步阅读.\n另外还找到另外一片博客[vue-cli的webpack模板项目配置文件分析](http://blog.csdn.net/hongchh/article/details/55113751)\n加上前面滴滴那篇介绍,对比读起来肯定会理解的快.\n总之,网上有已有大量的学习资料,前人栽树,后人乘凉,感谢.\n## config/index.js\n        \n        // see http://vuejs-templates.github.io/webpack for documentation.\n        // path是node.js的路径模块，用来处理路径统一的问题\n        var path = require('path')\n        \n        module.exports = {\n            // 下面是build也就是生产编译环境下的一些配置\n            build: {\n                // 导入prod.env.js配置文件，只要用来指定当前环境，详细见(1)\n                env: require('./prod.env'),\n                // 下面是相对路径的拼接，假如当前跟目录是config，那么下面配置的index属性的属性值就是dist/index.html\n                index: path.resolve(__dirname, '../dist/index.html'),\n                // 下面定义的是静态资源的根目录 也就是dist目录\n                assetsRoot: path.resolve(__dirname, '../dist'),\n                // 下面定义的是静态资源根目录的子目录static，也就是dist目录下面的static\n                assetsSubDirectory: 'static',\n                // 下面定义的是静态资源的公开路径，也就是真正的引用路径\n                assetsPublicPath: '/',\n                // 下面定义是否生成生产环境的sourcmap，sourcmap是用来debug编译后文件的，通过映射到编译前文件来实现\n                productionSourceMap: true,\n                // Gzip off by default as many popular static hosts such as\n                // Surge or Netlify already gzip all static assets for you.\n                // Before setting to `true`, make sure to:\n                // npm install --save-dev compression-webpack-plugin\n                // 下面是是否在生产环境中压缩代码，如果要压缩必须安装compression-webpack-plugin\n                productionGzip: false,\n                // 下面定义要压缩哪些类型的文件\n                productionGzipExtensions: ['js', 'css'],\n                // Run the build command with an extra argument to\n                // View the bundle analyzer report after build finishes:\n                // `npm run build --report`\n                // Set to `true` or `false` to always turn it on or off\n                // 下面是用来开启编译完成后的报告，可以通过设置值为true和false来开启或关闭\n                // 下面的process.env.npm_config_report表示定义的一个npm_config_report环境变量，可以自行设置\n                bundleAnalyzerReport: process.env.npm_config_report\n            },\n            dev: {\n                // 引入当前目录下的dev.env.js，用来指明开发环境，详见(2)\n                env: require('./dev.env'),\n                // 下面是dev-server的端口号，可以自行更改\n                port: 8080,\n                // 下面表示是否自定代开浏览器\n                autoOpenBrowser: true,\n                assetsSubDirectory: 'static',\n                assetsPublicPath: '/',\n                // 下面是代理表，作用是用来，建一个虚拟api服务器用来代理本机的请求，只能用于开发模式\n                // 详见(3)\n                proxyTable: {},\n                // CSS Sourcemaps off by default because relative paths are \"buggy\"\n                // with this option, according to the CSS-Loader README\n                // (https://github.com/webpack/css-loader#sourcemaps)\n                // In our experience, they generally work as expected,\n                // just be aware of this issue when enabling this option.\n                // 是否生成css，map文件，上面这段英文就是说使用这个cssmap可能存在问题，但是按照经验，问题不大，可以使用\n                // 给人觉得没必要用这个，css出了问题，直接控制台不就完事了\n                cssSourceMap: false\n            }\n        }\n<!-- more -->        \n## prod.env.js \n        \n         module.exports = {\n                // 作用很明显，就是导出一个对象，NODE_ENV是一个环境变量，指定production环境\n                NODE_ENV: '\"production\"'\n            }\n\n## dev.env.js\n        \n         // 首先引入的是webpack的merge插件，该插件是用来合并对象，也就是配置文件用的，相同的选项会被覆盖，至于这里为什么多次一举，可能另有他图吧\n            var merge = require('webpack-merge')\n            // 导入prod.env.js配置文件\n            var prodEnv = require('./prod.env')\n            // 将两个配置对象合并，最终结果是 NODE_ENV: '\"development\"'\n            module.exports = merge(prodEnv, {\n                NODE_ENV: '\"development\"'\n            })\n            \n## proxyTable用法\n           \n           vue-cli使用这个功能是借助http-proxy-middleware插件，一般解决跨域请求api\n               proxyTable: {\n                   '/list': {\n                       target: 'http://api.xxxxxxxx.com', -> 目标url地址\n                       changeOrigin: true, -> 指示是否跨域\n                       pathRewrite: {\n                       '^/list': '/list' -> 可以使用 /list 等价于 api.xxxxxxxx.com/list\n                       }\n                   }\n               }\n            \n            ","slug":"vue-cli-2中webpack的配置分析二","published":1,"updated":"2018-09-14T16:38:30.818Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm28whm900057rs65utz6r3f","content":"<p>这片也是转载,<a href=\"http://www.cnblogs.com/ye-hcj/p/7077796.html\" target=\"_blank\" rel=\"noopener\">叶家伟的博客</a>,这里有一系列的vue-cli中webpack分析文章,可以移步阅读.<br>另外还找到另外一片博客<a href=\"http://blog.csdn.net/hongchh/article/details/55113751\" target=\"_blank\" rel=\"noopener\">vue-cli的webpack模板项目配置文件分析</a><br>加上前面滴滴那篇介绍,对比读起来肯定会理解的快.<br>总之,网上有已有大量的学习资料,前人栽树,后人乘凉,感谢.</p>\n<h2 id=\"config-index-js\"><a href=\"#config-index-js\" class=\"headerlink\" title=\"config/index.js\"></a>config/index.js</h2><pre><code>// see http://vuejs-templates.github.io/webpack for documentation.\n// path是node.js的路径模块，用来处理路径统一的问题\nvar path = require(&apos;path&apos;)\n\nmodule.exports = {\n    // 下面是build也就是生产编译环境下的一些配置\n    build: {\n        // 导入prod.env.js配置文件，只要用来指定当前环境，详细见(1)\n        env: require(&apos;./prod.env&apos;),\n        // 下面是相对路径的拼接，假如当前跟目录是config，那么下面配置的index属性的属性值就是dist/index.html\n        index: path.resolve(__dirname, &apos;../dist/index.html&apos;),\n        // 下面定义的是静态资源的根目录 也就是dist目录\n        assetsRoot: path.resolve(__dirname, &apos;../dist&apos;),\n        // 下面定义的是静态资源根目录的子目录static，也就是dist目录下面的static\n        assetsSubDirectory: &apos;static&apos;,\n        // 下面定义的是静态资源的公开路径，也就是真正的引用路径\n        assetsPublicPath: &apos;/&apos;,\n        // 下面定义是否生成生产环境的sourcmap，sourcmap是用来debug编译后文件的，通过映射到编译前文件来实现\n        productionSourceMap: true,\n        // Gzip off by default as many popular static hosts such as\n        // Surge or Netlify already gzip all static assets for you.\n        // Before setting to `true`, make sure to:\n        // npm install --save-dev compression-webpack-plugin\n        // 下面是是否在生产环境中压缩代码，如果要压缩必须安装compression-webpack-plugin\n        productionGzip: false,\n        // 下面定义要压缩哪些类型的文件\n        productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;],\n        // Run the build command with an extra argument to\n        // View the bundle analyzer report after build finishes:\n        // `npm run build --report`\n        // Set to `true` or `false` to always turn it on or off\n        // 下面是用来开启编译完成后的报告，可以通过设置值为true和false来开启或关闭\n        // 下面的process.env.npm_config_report表示定义的一个npm_config_report环境变量，可以自行设置\n        bundleAnalyzerReport: process.env.npm_config_report\n    },\n    dev: {\n        // 引入当前目录下的dev.env.js，用来指明开发环境，详见(2)\n        env: require(&apos;./dev.env&apos;),\n        // 下面是dev-server的端口号，可以自行更改\n        port: 8080,\n        // 下面表示是否自定代开浏览器\n        autoOpenBrowser: true,\n        assetsSubDirectory: &apos;static&apos;,\n        assetsPublicPath: &apos;/&apos;,\n        // 下面是代理表，作用是用来，建一个虚拟api服务器用来代理本机的请求，只能用于开发模式\n        // 详见(3)\n        proxyTable: {},\n        // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot;\n        // with this option, according to the CSS-Loader README\n        // (https://github.com/webpack/css-loader#sourcemaps)\n        // In our experience, they generally work as expected,\n        // just be aware of this issue when enabling this option.\n        // 是否生成css，map文件，上面这段英文就是说使用这个cssmap可能存在问题，但是按照经验，问题不大，可以使用\n        // 给人觉得没必要用这个，css出了问题，直接控制台不就完事了\n        cssSourceMap: false\n    }\n}\n</code></pre><a id=\"more\"></a>        \n<h2 id=\"prod-env-js\"><a href=\"#prod-env-js\" class=\"headerlink\" title=\"prod.env.js\"></a>prod.env.js</h2><pre><code>module.exports = {\n       // 作用很明显，就是导出一个对象，NODE_ENV是一个环境变量，指定production环境\n       NODE_ENV: &apos;&quot;production&quot;&apos;\n   }\n</code></pre><h2 id=\"dev-env-js\"><a href=\"#dev-env-js\" class=\"headerlink\" title=\"dev.env.js\"></a>dev.env.js</h2><pre><code>// 首先引入的是webpack的merge插件，该插件是用来合并对象，也就是配置文件用的，相同的选项会被覆盖，至于这里为什么多次一举，可能另有他图吧\n   var merge = require(&apos;webpack-merge&apos;)\n   // 导入prod.env.js配置文件\n   var prodEnv = require(&apos;./prod.env&apos;)\n   // 将两个配置对象合并，最终结果是 NODE_ENV: &apos;&quot;development&quot;&apos;\n   module.exports = merge(prodEnv, {\n       NODE_ENV: &apos;&quot;development&quot;&apos;\n   })\n</code></pre><h2 id=\"proxyTable用法\"><a href=\"#proxyTable用法\" class=\"headerlink\" title=\"proxyTable用法\"></a>proxyTable用法</h2><pre><code>vue-cli使用这个功能是借助http-proxy-middleware插件，一般解决跨域请求api\n    proxyTable: {\n        &apos;/list&apos;: {\n            target: &apos;http://api.xxxxxxxx.com&apos;, -&gt; 目标url地址\n            changeOrigin: true, -&gt; 指示是否跨域\n            pathRewrite: {\n            &apos;^/list&apos;: &apos;/list&apos; -&gt; 可以使用 /list 等价于 api.xxxxxxxx.com/list\n            }\n        }\n    }\n</code></pre>","site":{"data":{}},"excerpt":"<p>这片也是转载,<a href=\"http://www.cnblogs.com/ye-hcj/p/7077796.html\" target=\"_blank\" rel=\"noopener\">叶家伟的博客</a>,这里有一系列的vue-cli中webpack分析文章,可以移步阅读.<br>另外还找到另外一片博客<a href=\"http://blog.csdn.net/hongchh/article/details/55113751\" target=\"_blank\" rel=\"noopener\">vue-cli的webpack模板项目配置文件分析</a><br>加上前面滴滴那篇介绍,对比读起来肯定会理解的快.<br>总之,网上有已有大量的学习资料,前人栽树,后人乘凉,感谢.</p>\n<h2 id=\"config-index-js\"><a href=\"#config-index-js\" class=\"headerlink\" title=\"config/index.js\"></a>config/index.js</h2><pre><code>// see http://vuejs-templates.github.io/webpack for documentation.\n// path是node.js的路径模块，用来处理路径统一的问题\nvar path = require(&apos;path&apos;)\n\nmodule.exports = {\n    // 下面是build也就是生产编译环境下的一些配置\n    build: {\n        // 导入prod.env.js配置文件，只要用来指定当前环境，详细见(1)\n        env: require(&apos;./prod.env&apos;),\n        // 下面是相对路径的拼接，假如当前跟目录是config，那么下面配置的index属性的属性值就是dist/index.html\n        index: path.resolve(__dirname, &apos;../dist/index.html&apos;),\n        // 下面定义的是静态资源的根目录 也就是dist目录\n        assetsRoot: path.resolve(__dirname, &apos;../dist&apos;),\n        // 下面定义的是静态资源根目录的子目录static，也就是dist目录下面的static\n        assetsSubDirectory: &apos;static&apos;,\n        // 下面定义的是静态资源的公开路径，也就是真正的引用路径\n        assetsPublicPath: &apos;/&apos;,\n        // 下面定义是否生成生产环境的sourcmap，sourcmap是用来debug编译后文件的，通过映射到编译前文件来实现\n        productionSourceMap: true,\n        // Gzip off by default as many popular static hosts such as\n        // Surge or Netlify already gzip all static assets for you.\n        // Before setting to `true`, make sure to:\n        // npm install --save-dev compression-webpack-plugin\n        // 下面是是否在生产环境中压缩代码，如果要压缩必须安装compression-webpack-plugin\n        productionGzip: false,\n        // 下面定义要压缩哪些类型的文件\n        productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;],\n        // Run the build command with an extra argument to\n        // View the bundle analyzer report after build finishes:\n        // `npm run build --report`\n        // Set to `true` or `false` to always turn it on or off\n        // 下面是用来开启编译完成后的报告，可以通过设置值为true和false来开启或关闭\n        // 下面的process.env.npm_config_report表示定义的一个npm_config_report环境变量，可以自行设置\n        bundleAnalyzerReport: process.env.npm_config_report\n    },\n    dev: {\n        // 引入当前目录下的dev.env.js，用来指明开发环境，详见(2)\n        env: require(&apos;./dev.env&apos;),\n        // 下面是dev-server的端口号，可以自行更改\n        port: 8080,\n        // 下面表示是否自定代开浏览器\n        autoOpenBrowser: true,\n        assetsSubDirectory: &apos;static&apos;,\n        assetsPublicPath: &apos;/&apos;,\n        // 下面是代理表，作用是用来，建一个虚拟api服务器用来代理本机的请求，只能用于开发模式\n        // 详见(3)\n        proxyTable: {},\n        // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot;\n        // with this option, according to the CSS-Loader README\n        // (https://github.com/webpack/css-loader#sourcemaps)\n        // In our experience, they generally work as expected,\n        // just be aware of this issue when enabling this option.\n        // 是否生成css，map文件，上面这段英文就是说使用这个cssmap可能存在问题，但是按照经验，问题不大，可以使用\n        // 给人觉得没必要用这个，css出了问题，直接控制台不就完事了\n        cssSourceMap: false\n    }\n}\n</code></pre>","more":"<h2 id=\"prod-env-js\"><a href=\"#prod-env-js\" class=\"headerlink\" title=\"prod.env.js\"></a>prod.env.js</h2><pre><code>module.exports = {\n       // 作用很明显，就是导出一个对象，NODE_ENV是一个环境变量，指定production环境\n       NODE_ENV: &apos;&quot;production&quot;&apos;\n   }\n</code></pre><h2 id=\"dev-env-js\"><a href=\"#dev-env-js\" class=\"headerlink\" title=\"dev.env.js\"></a>dev.env.js</h2><pre><code>// 首先引入的是webpack的merge插件，该插件是用来合并对象，也就是配置文件用的，相同的选项会被覆盖，至于这里为什么多次一举，可能另有他图吧\n   var merge = require(&apos;webpack-merge&apos;)\n   // 导入prod.env.js配置文件\n   var prodEnv = require(&apos;./prod.env&apos;)\n   // 将两个配置对象合并，最终结果是 NODE_ENV: &apos;&quot;development&quot;&apos;\n   module.exports = merge(prodEnv, {\n       NODE_ENV: &apos;&quot;development&quot;&apos;\n   })\n</code></pre><h2 id=\"proxyTable用法\"><a href=\"#proxyTable用法\" class=\"headerlink\" title=\"proxyTable用法\"></a>proxyTable用法</h2><pre><code>vue-cli使用这个功能是借助http-proxy-middleware插件，一般解决跨域请求api\n    proxyTable: {\n        &apos;/list&apos;: {\n            target: &apos;http://api.xxxxxxxx.com&apos;, -&gt; 目标url地址\n            changeOrigin: true, -&gt; 指示是否跨域\n            pathRewrite: {\n            &apos;^/list&apos;: &apos;/list&apos; -&gt; 可以使用 /list 等价于 api.xxxxxxxx.com/list\n            }\n        }\n    }\n</code></pre>"},{"title":"vue-cli(#2)中webpack的配置(一)","date":"2017-10-07T14:39:39.000Z","_content":"这篇基本上转载自滴滴前端团队的一片文章,感谢这样优秀的前端团队.\n\n## 目录结构\n\n    .\n    ├── README.md\n    ├── build\n    │   ├── build.js\n    │   ├── check-versions.js\n    │   ├── dev-client.js\n    │   ├── dev-server.js\n    │   ├── utils.js\n    │   ├── webpack.base.conf.js\n    │   ├── webpack.dev.conf.js\n    │   └── webpack.prod.conf.js\n    ├── config\n    │   ├── dev.env.js\n    │   ├── index.js\n    │   └── prod.env.js\n    ├── index.html\n    ├── package.json\n    ├── src\n    │   ├── App.vue\n    │   ├── assets\n    │   │   └── logo.png\n    │   ├── components\n    │   │   └── Hello.vue\n    │   └── main.js\n    └── static\n    \n<!-- more -->    \n## package.json\n我们可以看到\n   \n       \"scripts\": {\n           \"dev\": \"node build/dev-server.js\",\n           \"build\": \"node build/build.js\",\n           \"lint\": \"eslint --ext .js,.vue src\"\n       }\n   \n   当我们执行 npm run dev / npm run build 时运行的是 node build/dev-server.js 或 node build/build.js\n   \n## dev-server.js\n   \n        // 检查 Node 和 npm 版本\n        require('./check-versions')()\n        \n        // 获取 config/index.js 的默认配置\n        var config = require('../config')\n        \n        // 如果 Node 的环境无法判断当前是 dev / product 环境\n        // 使用 config.dev.env.NODE_ENV 作为当前的环境\n        \n        if (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)\n        \n        // 使用 NodeJS 自带的文件路径工具\n        var path = require('path')\n        \n        // 使用 express\n        var express = require('express')\n        \n        // 使用 webpack\n        var webpack = require('webpack')\n        \n        // 一个可以强制打开浏览器并跳转到指定 url 的插件\n        var opn = require('opn')\n        \n        // 使用 proxyTable\n        var proxyMiddleware = require('http-proxy-middleware')\n        \n        // 使用 dev 环境的 webpack 配置\n        var webpackConfig = require('./webpack.dev.conf')\n        \n        // default port where dev server listens for incoming traffic\n        \n        // 如果没有指定运行端口，使用 config.dev.port 作为运行端口\n        var port = process.env.PORT || config.dev.port\n        \n        // Define HTTP proxies to your custom API backend\n        // https://github.com/chimurai/http-proxy-middleware\n        \n        // 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置\n        var proxyTable = config.dev.proxyTable\n        \n        // 使用 express 启动一个服务\n        var app = express()\n        \n        // 启动 webpack 进行编译\n        var compiler = webpack(webpackConfig)\n        \n        // 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中\n        var devMiddleware = require('webpack-dev-middleware')(compiler, {\n          publicPath: webpackConfig.output.publicPath,\n          stats: {\n            colors: true,\n            chunks: false\n          }\n        })\n        \n        // 启动 webpack-hot-middleware，也就是我们常说的 Hot-reload\n        var hotMiddleware = require('webpack-hot-middleware')(compiler)\n        // force page reload when html-webpack-plugin template changes\n        compiler.plugin('compilation', function (compilation) {\n          compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) {\n            hotMiddleware.publish({ action: 'reload' })\n            cb()\n          })\n        })\n        \n        // proxy api requests\n        // 将 proxyTable 中的请求配置挂在到启动的 express 服务上\n        Object.keys(proxyTable).forEach(function (context) {\n          var options = proxyTable[context]\n          if (typeof options === 'string') {\n            options = { target: options }\n          }\n          app.use(proxyMiddleware(context, options))\n        })\n        \n        // handle fallback for HTML5 history API\n        // 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址\n        app.use(require('connect-history-api-fallback')())\n        \n        // serve webpack bundle output\n        // 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上\n        app.use(devMiddleware)\n        \n        // enable hot-reload and state-preserving\n        // compilation error display\n        // 将 Hot-reload 挂在到 express 服务上\n        app.use(hotMiddleware)\n        \n        // serve pure static assets\n        // 拼接 static 文件夹的静态资源路径\n        var staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)\n        // 为静态资源提供响应服务\n        app.use(staticPath, express.static('./static'))\n        \n        // 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露\n        module.exports = app.listen(port, function (err) {\n          if (err) {\n            console.log(err)\n            return\n          }\n          var uri = 'http://localhost:' + port\n          console.log('Listening at ' + uri + '\\n')\n        \n          // when env is testing, don't need open it\n          // 如果不是测试环境，自动打开浏览器并跳到我们的开发地址\n          if (process.env.NODE_ENV !== 'testing') {\n            opn(uri)\n          }\n        })\n           \n           \n   \n## webpack.dev.conf.js\n        \n        // 同样的使用了 config/index.js\n        var config = require('../config') \n        \n        // 使用 webpack\n        var webpack = require('webpack') \n        \n        // 使用 webpack 配置合并插件\n        var merge = require('webpack-merge') \n        \n        // 使用一些小工具\n        var utils = require('./utils') \n        \n        // 加载 webpack.base.conf\n        var baseWebpackConfig = require('./webpack.base.conf') \n        \n        // 使用 html-webpack-plugin 插件，这个插件可以帮我们自动生成 html 并且注入到 .html 文件中\n        var HtmlWebpackPlugin = require('html-webpack-plugin') \n        \n        // add hot-reload related code to entry chunks\n        // 将 Hol-reload 相对路径添加到 webpack.base.conf 的 对应 entry 前\n        Object.keys(baseWebpackConfig.entry).forEach(function (name) {\n          baseWebpackConfig.entry[name] = ['./build/dev-client'].concat(baseWebpackConfig.entry[name])\n        })\n        \n        // 将我们 webpack.dev.conf.js 的配置和 webpack.base.conf.js 的配置合并\n        module.exports = merge(baseWebpackConfig, {\n          module: {\n            // 使用 styleLoaders\n            loaders: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap })\n          },\n          // eval-source-map is faster for development\n          // 使用 #eval-source-map 模式作为开发工具，此配置可参考 DDFE 往期文章详细了解\n          devtool: '#eval-source-map',\n          plugins: [\n        \n            // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串\n            new webpack.DefinePlugin({\n              'process.env': config.dev.env\n            }),\n            // https://github.com/glenjamin/webpack-hot-middleware#installation--usage\n            new webpack.optimize.OccurenceOrderPlugin(),\n        \n            // HotModule 插件在页面进行变更的时候只会重回对应的页面模块，不会重绘整个 html 文件\n            new webpack.HotModuleReplacementPlugin(),\n        \n            // 使用了 NoErrorsPlugin 后页面中的报错不会阻塞，但是会在编译结束后报错\n            new webpack.NoErrorsPlugin(),\n            // https://github.com/ampedandwired/html-webpack-plugin\n        \n            // 将 index.html 作为入口，注入 html 代码后生成 index.html文件\n            new HtmlWebpackPlugin({\n              filename: 'index.html',\n              template: 'index.html',\n              inject: true\n            })\n          ]\n        })\n\n    \n## webpack.base.conf.js\n我们看到在 webpack.dev.conf.js 中又引入了 webpack.base.conf.js\n        \n        // 使用 NodeJS 自带的文件路径插件\n        var path = require('path') \n        \n        // 引入 config/index.js\n        var config = require('../config') \n        \n        // 引入一些小工具\n        var utils = require('./utils') \n        \n        // 拼接我们的工作区路径为一个绝对路径\n        var projectRoot = path.resolve(__dirname, '../') \n        \n        // 将 NodeJS 环境作为我们的编译环境\n        var env = process.env.NODE_ENV\n        \n        // check env & config/index.js to decide weither to enable CSS Sourcemaps for the\n        // various preprocessor loaders added to vue-loader at the end of this file\n        \n        // 是否在 dev 环境下开启 cssSourceMap ，在 config/index.js 中可配置\n        var cssSourceMapDev = (env === 'development' && config.dev.cssSourceMap)\n        \n        // 是否在 production 环境下开启 cssSourceMap ，在 config/index.js 中可配置\n        var cssSourceMapProd = (env === 'production' && config.build.productionSourceMap)\n        \n        // 最终是否使用 cssSourceMap\n        var useCssSourceMap = cssSourceMapDev || cssSourceMapProd\n        \n        module.exports = {\n          entry: {\n              // 编译文件入口\n            app: './src/main.js' \n          },\n          output: {\n              // 编译输出的根路径\n            path: config.build.assetsRoot, \n            // 正式发布环境下编译输出的发布路径\n            publicPath: process.env.NODE_ENV === 'production' ? config.build.assetsPublicPath : config.dev.assetsPublicPath, \n            // 编译输出的文件名\n            filename: '[name].js' \n          },\n          resolve: {\n            // 自动补全的扩展名\n            extensions: ['', '.js', '.vue'],\n            // 不进行自动补全或处理的文件或者文件夹\n            fallback: [path.join(__dirname, '../node_modules')],\n            alias: {\n            // 默认路径代理，例如 import Vue from 'vue'，会自动到 'vue/dist/vue.common.js'中寻找\n              'vue': 'vue/dist/vue.common.js',\n              'src': path.resolve(__dirname, '../src'),\n              'assets': path.resolve(__dirname, '../src/assets'),\n              'components': path.resolve(__dirname, '../src/components')\n            }\n          },\n          resolveLoader: {\n            fallback: [path.join(__dirname, '../node_modules')]\n          },\n          module: {\n            preLoaders: [\n              // 预处理的文件及使用的 loader\n              {\n                test: /\\.vue$/,\n                loader: 'eslint',\n                include: projectRoot,\n                exclude: /node_modules/\n              },\n              {\n                test: /\\.js$/,\n                loader: 'eslint',\n                include: projectRoot,\n                exclude: /node_modules/\n              }\n            ],\n            loaders: [\n              // 需要处理的文件及使用的 loader\n              {\n                test: /\\.vue$/,\n                loader: 'vue'\n              },\n              {\n                test: /\\.js$/,\n                loader: 'babel',\n                include: projectRoot,\n                exclude: /node_modules/\n              },\n              {\n                test: /\\.json$/,\n                loader: 'json'\n              },\n              {\n                test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n                loader: 'url',\n                query: {\n                  limit: 10000,\n                  name: utils.assetsPath('img/[name].[hash:7].[ext]')\n                }\n              },\n              {\n                test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n                loader: 'url',\n                query: {\n                  limit: 10000,\n                  name: utils.assetsPath('fonts/[name].[hash:7].[ext]')\n                }\n              }\n            ]\n          },\n          eslint: {\n            // eslint 代码检查配置工具\n            formatter: require('eslint-friendly-formatter')\n          },\n          vue: {\n            // .vue 文件配置 loader 及工具 (autoprefixer)\n            loaders: utils.cssLoaders({ sourceMap: useCssSourceMap }),\n            postcss: [\n              require('autoprefixer')({\n                browsers: ['last 2 versions']\n              })\n            ]\n          }\n        }    \n        \n## config/index.js\n   \n终于分析完了 webpack.base.conf.js，来让我们看一下 config/index.js\n   \nindex.js 中有 dev 和 production 两种环境的配置 \n       \n       // see http://vuejs-templates.github.io/webpack for documentation.\n       // 不再重复介绍了 ...\n       var path = require('path')\n       \n       module.exports = {\n         // production 环境\n         build: { \n             // 使用 config/prod.env.js 中定义的编译环境\n           env: require('./prod.env'), \n           index: path.resolve(__dirname, '../dist/index.html'), // 编译输入的 index.html 文件\n           // 编译输出的静态资源根路径\n           assetsRoot: path.resolve(__dirname, '../dist'), \n           // 编译输出的二级目录\n           assetsSubDirectory: 'static', \n           // 编译发布上线路径的根目录，可配置为资源服务器域名或 CDN 域名\n           assetsPublicPath: '/', \n           // 是否开启 cssSourceMap\n           productionSourceMap: true, \n           // Gzip off by default as many popular static hosts such as\n           // Surge or Netlify already gzip all static assets for you.\n           // Before setting to `true`, make sure to:\n           // npm install --save-dev compression-webpack-plugin\n           // 是否开启 gzip\n           productionGzip: false, \n           // 需要使用 gzip 压缩的文件扩展名\n           productionGzipExtensions: ['js', 'css'] \n         },\n         // dev 环境\n         dev: { \n             // 使用 config/dev.env.js 中定义的编译环境\n           env: require('./dev.env'), \n           // 运行测试页面的端口\n           port: 8080, \n           // 编译输出的二级目录\n           assetsSubDirectory: 'static', \n           // 编译发布上线路径的根目录，可配置为资源服务器域名或 CDN 域名\n           assetsPublicPath: '/', \n           // 需要 proxyTable 代理的接口（可跨域）\n           proxyTable: {}, \n           // CSS Sourcemaps off by default because relative paths are \"buggy\"\n           // with this option, according to the CSS-Loader README\n           // (https://github.com/webpack/css-loader#sourcemaps)\n           // In our experience, they generally work as expected,\n           // just be aware of this issue when enabling this option.\n           // 是否开启 cssSourceMap\n           cssSourceMap: false \n         }\n       }\n  \n       \n至此，我们的 npm run dev 命令就讲解完毕，\n\n下面让我们来看一看执行 npm run build 命令时发生了什么 \n## build.js  \n     // https://github.com/shelljs/shelljs\n     \n     // 检查 Node 和 npm 版本\n     require('./check-versions')() \n     \n     // 使用了 shelljs 插件，可以让我们在 node 环境的 js 中使用 shell\n     require('shelljs/global') \n     env.NODE_ENV = 'production'\n     \n     // 不再赘述\n     var path = require('path') \n     \n     // 加载 config.js\n     var config = require('../config') \n     \n     // 一个很好看的 loading 插件\n     var ora = require('ora') \n     \n     // 加载 webpack\n     var webpack = require('webpack') \n     \n     // 加载 webpack.prod.conf\n     var webpackConfig = require('./webpack.prod.conf') \n     \n     //  输出提示信息 ～ 提示用户请在 http 服务下查看本页面，否则为空白页\n     console.log(\n       '  Tip:\\n' +\n       '  Built files are meant to be served over an HTTP server.\\n' +\n       '  Opening index.html over file:// won\\'t work.\\n'\n     )\n     \n     // 使用 ora 打印出 loading + log\n     var spinner = ora('building for production...') \n     // 开始 loading 动画\n     spinner.start() \n     \n     // 拼接编译输出文件路径\n     var assetsPath = path.join(config.build.assetsRoot, config.build.assetsSubDirectory)\n     // 删除这个文件夹 （递归删除）\n     rm('-rf', assetsPath)\n     // 创建此文件夹 \n     mkdir('-p', assetsPath)\n     // 复制 static 文件夹到我们的编译输出目录\n     cp('-R', 'static/*', assetsPath)\n     \n     //  开始 webpack 的编译\n     webpack(webpackConfig, function (err, stats) {\n       // 编译成功的回调函数\n       spinner.stop()\n       if (err) throw err\n       process.stdout.write(stats.toString({\n         colors: true,\n         modules: false,\n         children: false,\n         chunks: false,\n         chunkModules: false\n       }) + '\\n')\n     })\n     \n## webpack.prod.conf.js\n     // 不再赘述\n     var path = require('path')\n     \n     // 加载 confi.index.js\n     var config = require('../config')\n     \n     // 使用一些小工具\n     var utils = require('./utils') \n     \n     // 加载 webpack\n     var webpack = require('webpack') \n     \n     // 加载 webpack 配置合并工具\n     var merge = require('webpack-merge') \n     \n     // 加载 webpack.base.conf.js\n     var baseWebpackConfig = require('./webpack.base.conf') \n     \n     // 一个 webpack 扩展，可以提取一些代码并且将它们和文件分离开\n     // 如果我们想将 webpack 打包成一个文件 css js 分离开，那我们需要这个插件\n     var ExtractTextPlugin = require('extract-text-webpack-plugin')\n     \n     // 一个可以插入 html 并且创建新的 .html 文件的插件\n     var HtmlWebpackPlugin = require('html-webpack-plugin')\n     var env = config.build.env\n     \n     // 合并 webpack.base.conf.js\n     var webpackConfig = merge(baseWebpackConfig, {\n       module: {\n         // 使用的 loader\n         loaders: utils.styleLoaders({ sourceMap: config.build.productionSourceMap, extract: true })\n       },\n       // 是否使用 #source-map 开发工具，更多信息可以查看 DDFE 往期文章\n       devtool: config.build.productionSourceMap ? '#source-map' : false,\n       output: {\n         // 编译输出目录\n         path: config.build.assetsRoot,\n         // 编译输出文件名\n         // 我们可以在 hash 后加 :6 决定使用几位 hash 值\n         filename: utils.assetsPath('js/[name].[chunkhash].js'), \n         // 没有指定输出名的文件输出的文件名\n         chunkFilename: utils.assetsPath('js/[id].[chunkhash].js')\n       },\n       vue: {\n         // 编译 .vue 文件时使用的 loader\n         loaders: utils.cssLoaders({\n           sourceMap: config.build.productionSourceMap,\n           extract: true\n         })\n       },\n       plugins: [\n         // 使用的插件\n         // http://vuejs.github.io/vue-loader/en/workflow/production.html\n         // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串\n         new webpack.DefinePlugin({\n           'process.env': env\n         }),\n         // 压缩 js (同样可以压缩 css)\n         new webpack.optimize.UglifyJsPlugin({\n           compress: {\n             warnings: false\n           }\n         }),\n         new webpack.optimize.OccurrenceOrderPlugin(),\n         // extract css into its own file\n         // 将 css 文件分离出来\n         new ExtractTextPlugin(utils.assetsPath('css/[name].[contenthash].css')),\n         // generate dist index.html with correct asset hash for caching.\n         // you can customize output by editing /index.html\n         // see https://github.com/ampedandwired/html-webpack-plugin\n         // 输入输出的 .html 文件\n         new HtmlWebpackPlugin({\n           filename: config.build.index,\n           template: 'index.html',\n           // 是否注入 html\n           inject: true, \n           // 压缩的方式\n           minify: { \n             removeComments: true,\n             collapseWhitespace: true,\n             removeAttributeQuotes: true\n             // more options:\n             // https://github.com/kangax/html-minifier#options-quick-reference\n           },\n           // necessary to consistently work with multiple chunks via CommonsChunkPlugin\n           chunksSortMode: 'dependency'\n         }),\n         // split vendor js into its own file\n         // 没有指定输出文件名的文件输出的静态文件名\n         new webpack.optimize.CommonsChunkPlugin({\n           name: 'vendor',\n           minChunks: function (module, count) {\n             // any required modules inside node_modules are extracted to vendor\n             return (\n               module.resource &&\n               /\\.js$/.test(module.resource) &&\n               module.resource.indexOf(\n                 path.join(__dirname, '../node_modules')\n               ) === 0\n             )\n           }\n         }),\n         // extract webpack runtime and module manifest to its own file in order to\n         // prevent vendor hash from being updated whenever app bundle is updated\n         // 没有指定输出文件名的文件输出的静态文件名\n         new webpack.optimize.CommonsChunkPlugin({\n           name: 'manifest',\n           chunks: ['vendor']\n         })\n       ]\n     })\n     \n     // 开启 gzip 的情况下使用下方的配置\n     if (config.build.productionGzip) {\n       // 加载 compression-webpack-plugin 插件\n       var CompressionWebpackPlugin =  require('compression-webpack-plugin')\n       // 向webpackconfig.plugins中加入下方的插件\n       var reProductionGzipExtensions = '\\\\.(' + config.build.productionGzipExtensions.join('|') + '$)'\n       webpackConfig.plugins.push(\n         // 使用 compression-webpack-plugin 插件进行压缩\n         new CompressionWebpackPlugin({\n           asset: '[path].gz[query]',\n           algorithm: 'gzip',\n           test: new RegExp(reProductionGzipExtensions), // 注：此处因有代码格式化的bug，与源码有差异\n           threshold: 10240,\n           minRatio: 0.8\n         })\n       )\n     }\n     \n     module.exports = webpackConfig","source":"_posts/vue-cli-2-中webpack的配置-一.md","raw":"---\ntitle: 'vue-cli(#2)中webpack的配置(一)'\ndate: 2017-10-07 22:39:39\ntags: [webpack,vue-cli,vue]\ncategories: [front]\n---\n这篇基本上转载自滴滴前端团队的一片文章,感谢这样优秀的前端团队.\n\n## 目录结构\n\n    .\n    ├── README.md\n    ├── build\n    │   ├── build.js\n    │   ├── check-versions.js\n    │   ├── dev-client.js\n    │   ├── dev-server.js\n    │   ├── utils.js\n    │   ├── webpack.base.conf.js\n    │   ├── webpack.dev.conf.js\n    │   └── webpack.prod.conf.js\n    ├── config\n    │   ├── dev.env.js\n    │   ├── index.js\n    │   └── prod.env.js\n    ├── index.html\n    ├── package.json\n    ├── src\n    │   ├── App.vue\n    │   ├── assets\n    │   │   └── logo.png\n    │   ├── components\n    │   │   └── Hello.vue\n    │   └── main.js\n    └── static\n    \n<!-- more -->    \n## package.json\n我们可以看到\n   \n       \"scripts\": {\n           \"dev\": \"node build/dev-server.js\",\n           \"build\": \"node build/build.js\",\n           \"lint\": \"eslint --ext .js,.vue src\"\n       }\n   \n   当我们执行 npm run dev / npm run build 时运行的是 node build/dev-server.js 或 node build/build.js\n   \n## dev-server.js\n   \n        // 检查 Node 和 npm 版本\n        require('./check-versions')()\n        \n        // 获取 config/index.js 的默认配置\n        var config = require('../config')\n        \n        // 如果 Node 的环境无法判断当前是 dev / product 环境\n        // 使用 config.dev.env.NODE_ENV 作为当前的环境\n        \n        if (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)\n        \n        // 使用 NodeJS 自带的文件路径工具\n        var path = require('path')\n        \n        // 使用 express\n        var express = require('express')\n        \n        // 使用 webpack\n        var webpack = require('webpack')\n        \n        // 一个可以强制打开浏览器并跳转到指定 url 的插件\n        var opn = require('opn')\n        \n        // 使用 proxyTable\n        var proxyMiddleware = require('http-proxy-middleware')\n        \n        // 使用 dev 环境的 webpack 配置\n        var webpackConfig = require('./webpack.dev.conf')\n        \n        // default port where dev server listens for incoming traffic\n        \n        // 如果没有指定运行端口，使用 config.dev.port 作为运行端口\n        var port = process.env.PORT || config.dev.port\n        \n        // Define HTTP proxies to your custom API backend\n        // https://github.com/chimurai/http-proxy-middleware\n        \n        // 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置\n        var proxyTable = config.dev.proxyTable\n        \n        // 使用 express 启动一个服务\n        var app = express()\n        \n        // 启动 webpack 进行编译\n        var compiler = webpack(webpackConfig)\n        \n        // 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中\n        var devMiddleware = require('webpack-dev-middleware')(compiler, {\n          publicPath: webpackConfig.output.publicPath,\n          stats: {\n            colors: true,\n            chunks: false\n          }\n        })\n        \n        // 启动 webpack-hot-middleware，也就是我们常说的 Hot-reload\n        var hotMiddleware = require('webpack-hot-middleware')(compiler)\n        // force page reload when html-webpack-plugin template changes\n        compiler.plugin('compilation', function (compilation) {\n          compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) {\n            hotMiddleware.publish({ action: 'reload' })\n            cb()\n          })\n        })\n        \n        // proxy api requests\n        // 将 proxyTable 中的请求配置挂在到启动的 express 服务上\n        Object.keys(proxyTable).forEach(function (context) {\n          var options = proxyTable[context]\n          if (typeof options === 'string') {\n            options = { target: options }\n          }\n          app.use(proxyMiddleware(context, options))\n        })\n        \n        // handle fallback for HTML5 history API\n        // 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址\n        app.use(require('connect-history-api-fallback')())\n        \n        // serve webpack bundle output\n        // 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上\n        app.use(devMiddleware)\n        \n        // enable hot-reload and state-preserving\n        // compilation error display\n        // 将 Hot-reload 挂在到 express 服务上\n        app.use(hotMiddleware)\n        \n        // serve pure static assets\n        // 拼接 static 文件夹的静态资源路径\n        var staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)\n        // 为静态资源提供响应服务\n        app.use(staticPath, express.static('./static'))\n        \n        // 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露\n        module.exports = app.listen(port, function (err) {\n          if (err) {\n            console.log(err)\n            return\n          }\n          var uri = 'http://localhost:' + port\n          console.log('Listening at ' + uri + '\\n')\n        \n          // when env is testing, don't need open it\n          // 如果不是测试环境，自动打开浏览器并跳到我们的开发地址\n          if (process.env.NODE_ENV !== 'testing') {\n            opn(uri)\n          }\n        })\n           \n           \n   \n## webpack.dev.conf.js\n        \n        // 同样的使用了 config/index.js\n        var config = require('../config') \n        \n        // 使用 webpack\n        var webpack = require('webpack') \n        \n        // 使用 webpack 配置合并插件\n        var merge = require('webpack-merge') \n        \n        // 使用一些小工具\n        var utils = require('./utils') \n        \n        // 加载 webpack.base.conf\n        var baseWebpackConfig = require('./webpack.base.conf') \n        \n        // 使用 html-webpack-plugin 插件，这个插件可以帮我们自动生成 html 并且注入到 .html 文件中\n        var HtmlWebpackPlugin = require('html-webpack-plugin') \n        \n        // add hot-reload related code to entry chunks\n        // 将 Hol-reload 相对路径添加到 webpack.base.conf 的 对应 entry 前\n        Object.keys(baseWebpackConfig.entry).forEach(function (name) {\n          baseWebpackConfig.entry[name] = ['./build/dev-client'].concat(baseWebpackConfig.entry[name])\n        })\n        \n        // 将我们 webpack.dev.conf.js 的配置和 webpack.base.conf.js 的配置合并\n        module.exports = merge(baseWebpackConfig, {\n          module: {\n            // 使用 styleLoaders\n            loaders: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap })\n          },\n          // eval-source-map is faster for development\n          // 使用 #eval-source-map 模式作为开发工具，此配置可参考 DDFE 往期文章详细了解\n          devtool: '#eval-source-map',\n          plugins: [\n        \n            // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串\n            new webpack.DefinePlugin({\n              'process.env': config.dev.env\n            }),\n            // https://github.com/glenjamin/webpack-hot-middleware#installation--usage\n            new webpack.optimize.OccurenceOrderPlugin(),\n        \n            // HotModule 插件在页面进行变更的时候只会重回对应的页面模块，不会重绘整个 html 文件\n            new webpack.HotModuleReplacementPlugin(),\n        \n            // 使用了 NoErrorsPlugin 后页面中的报错不会阻塞，但是会在编译结束后报错\n            new webpack.NoErrorsPlugin(),\n            // https://github.com/ampedandwired/html-webpack-plugin\n        \n            // 将 index.html 作为入口，注入 html 代码后生成 index.html文件\n            new HtmlWebpackPlugin({\n              filename: 'index.html',\n              template: 'index.html',\n              inject: true\n            })\n          ]\n        })\n\n    \n## webpack.base.conf.js\n我们看到在 webpack.dev.conf.js 中又引入了 webpack.base.conf.js\n        \n        // 使用 NodeJS 自带的文件路径插件\n        var path = require('path') \n        \n        // 引入 config/index.js\n        var config = require('../config') \n        \n        // 引入一些小工具\n        var utils = require('./utils') \n        \n        // 拼接我们的工作区路径为一个绝对路径\n        var projectRoot = path.resolve(__dirname, '../') \n        \n        // 将 NodeJS 环境作为我们的编译环境\n        var env = process.env.NODE_ENV\n        \n        // check env & config/index.js to decide weither to enable CSS Sourcemaps for the\n        // various preprocessor loaders added to vue-loader at the end of this file\n        \n        // 是否在 dev 环境下开启 cssSourceMap ，在 config/index.js 中可配置\n        var cssSourceMapDev = (env === 'development' && config.dev.cssSourceMap)\n        \n        // 是否在 production 环境下开启 cssSourceMap ，在 config/index.js 中可配置\n        var cssSourceMapProd = (env === 'production' && config.build.productionSourceMap)\n        \n        // 最终是否使用 cssSourceMap\n        var useCssSourceMap = cssSourceMapDev || cssSourceMapProd\n        \n        module.exports = {\n          entry: {\n              // 编译文件入口\n            app: './src/main.js' \n          },\n          output: {\n              // 编译输出的根路径\n            path: config.build.assetsRoot, \n            // 正式发布环境下编译输出的发布路径\n            publicPath: process.env.NODE_ENV === 'production' ? config.build.assetsPublicPath : config.dev.assetsPublicPath, \n            // 编译输出的文件名\n            filename: '[name].js' \n          },\n          resolve: {\n            // 自动补全的扩展名\n            extensions: ['', '.js', '.vue'],\n            // 不进行自动补全或处理的文件或者文件夹\n            fallback: [path.join(__dirname, '../node_modules')],\n            alias: {\n            // 默认路径代理，例如 import Vue from 'vue'，会自动到 'vue/dist/vue.common.js'中寻找\n              'vue': 'vue/dist/vue.common.js',\n              'src': path.resolve(__dirname, '../src'),\n              'assets': path.resolve(__dirname, '../src/assets'),\n              'components': path.resolve(__dirname, '../src/components')\n            }\n          },\n          resolveLoader: {\n            fallback: [path.join(__dirname, '../node_modules')]\n          },\n          module: {\n            preLoaders: [\n              // 预处理的文件及使用的 loader\n              {\n                test: /\\.vue$/,\n                loader: 'eslint',\n                include: projectRoot,\n                exclude: /node_modules/\n              },\n              {\n                test: /\\.js$/,\n                loader: 'eslint',\n                include: projectRoot,\n                exclude: /node_modules/\n              }\n            ],\n            loaders: [\n              // 需要处理的文件及使用的 loader\n              {\n                test: /\\.vue$/,\n                loader: 'vue'\n              },\n              {\n                test: /\\.js$/,\n                loader: 'babel',\n                include: projectRoot,\n                exclude: /node_modules/\n              },\n              {\n                test: /\\.json$/,\n                loader: 'json'\n              },\n              {\n                test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n                loader: 'url',\n                query: {\n                  limit: 10000,\n                  name: utils.assetsPath('img/[name].[hash:7].[ext]')\n                }\n              },\n              {\n                test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n                loader: 'url',\n                query: {\n                  limit: 10000,\n                  name: utils.assetsPath('fonts/[name].[hash:7].[ext]')\n                }\n              }\n            ]\n          },\n          eslint: {\n            // eslint 代码检查配置工具\n            formatter: require('eslint-friendly-formatter')\n          },\n          vue: {\n            // .vue 文件配置 loader 及工具 (autoprefixer)\n            loaders: utils.cssLoaders({ sourceMap: useCssSourceMap }),\n            postcss: [\n              require('autoprefixer')({\n                browsers: ['last 2 versions']\n              })\n            ]\n          }\n        }    \n        \n## config/index.js\n   \n终于分析完了 webpack.base.conf.js，来让我们看一下 config/index.js\n   \nindex.js 中有 dev 和 production 两种环境的配置 \n       \n       // see http://vuejs-templates.github.io/webpack for documentation.\n       // 不再重复介绍了 ...\n       var path = require('path')\n       \n       module.exports = {\n         // production 环境\n         build: { \n             // 使用 config/prod.env.js 中定义的编译环境\n           env: require('./prod.env'), \n           index: path.resolve(__dirname, '../dist/index.html'), // 编译输入的 index.html 文件\n           // 编译输出的静态资源根路径\n           assetsRoot: path.resolve(__dirname, '../dist'), \n           // 编译输出的二级目录\n           assetsSubDirectory: 'static', \n           // 编译发布上线路径的根目录，可配置为资源服务器域名或 CDN 域名\n           assetsPublicPath: '/', \n           // 是否开启 cssSourceMap\n           productionSourceMap: true, \n           // Gzip off by default as many popular static hosts such as\n           // Surge or Netlify already gzip all static assets for you.\n           // Before setting to `true`, make sure to:\n           // npm install --save-dev compression-webpack-plugin\n           // 是否开启 gzip\n           productionGzip: false, \n           // 需要使用 gzip 压缩的文件扩展名\n           productionGzipExtensions: ['js', 'css'] \n         },\n         // dev 环境\n         dev: { \n             // 使用 config/dev.env.js 中定义的编译环境\n           env: require('./dev.env'), \n           // 运行测试页面的端口\n           port: 8080, \n           // 编译输出的二级目录\n           assetsSubDirectory: 'static', \n           // 编译发布上线路径的根目录，可配置为资源服务器域名或 CDN 域名\n           assetsPublicPath: '/', \n           // 需要 proxyTable 代理的接口（可跨域）\n           proxyTable: {}, \n           // CSS Sourcemaps off by default because relative paths are \"buggy\"\n           // with this option, according to the CSS-Loader README\n           // (https://github.com/webpack/css-loader#sourcemaps)\n           // In our experience, they generally work as expected,\n           // just be aware of this issue when enabling this option.\n           // 是否开启 cssSourceMap\n           cssSourceMap: false \n         }\n       }\n  \n       \n至此，我们的 npm run dev 命令就讲解完毕，\n\n下面让我们来看一看执行 npm run build 命令时发生了什么 \n## build.js  \n     // https://github.com/shelljs/shelljs\n     \n     // 检查 Node 和 npm 版本\n     require('./check-versions')() \n     \n     // 使用了 shelljs 插件，可以让我们在 node 环境的 js 中使用 shell\n     require('shelljs/global') \n     env.NODE_ENV = 'production'\n     \n     // 不再赘述\n     var path = require('path') \n     \n     // 加载 config.js\n     var config = require('../config') \n     \n     // 一个很好看的 loading 插件\n     var ora = require('ora') \n     \n     // 加载 webpack\n     var webpack = require('webpack') \n     \n     // 加载 webpack.prod.conf\n     var webpackConfig = require('./webpack.prod.conf') \n     \n     //  输出提示信息 ～ 提示用户请在 http 服务下查看本页面，否则为空白页\n     console.log(\n       '  Tip:\\n' +\n       '  Built files are meant to be served over an HTTP server.\\n' +\n       '  Opening index.html over file:// won\\'t work.\\n'\n     )\n     \n     // 使用 ora 打印出 loading + log\n     var spinner = ora('building for production...') \n     // 开始 loading 动画\n     spinner.start() \n     \n     // 拼接编译输出文件路径\n     var assetsPath = path.join(config.build.assetsRoot, config.build.assetsSubDirectory)\n     // 删除这个文件夹 （递归删除）\n     rm('-rf', assetsPath)\n     // 创建此文件夹 \n     mkdir('-p', assetsPath)\n     // 复制 static 文件夹到我们的编译输出目录\n     cp('-R', 'static/*', assetsPath)\n     \n     //  开始 webpack 的编译\n     webpack(webpackConfig, function (err, stats) {\n       // 编译成功的回调函数\n       spinner.stop()\n       if (err) throw err\n       process.stdout.write(stats.toString({\n         colors: true,\n         modules: false,\n         children: false,\n         chunks: false,\n         chunkModules: false\n       }) + '\\n')\n     })\n     \n## webpack.prod.conf.js\n     // 不再赘述\n     var path = require('path')\n     \n     // 加载 confi.index.js\n     var config = require('../config')\n     \n     // 使用一些小工具\n     var utils = require('./utils') \n     \n     // 加载 webpack\n     var webpack = require('webpack') \n     \n     // 加载 webpack 配置合并工具\n     var merge = require('webpack-merge') \n     \n     // 加载 webpack.base.conf.js\n     var baseWebpackConfig = require('./webpack.base.conf') \n     \n     // 一个 webpack 扩展，可以提取一些代码并且将它们和文件分离开\n     // 如果我们想将 webpack 打包成一个文件 css js 分离开，那我们需要这个插件\n     var ExtractTextPlugin = require('extract-text-webpack-plugin')\n     \n     // 一个可以插入 html 并且创建新的 .html 文件的插件\n     var HtmlWebpackPlugin = require('html-webpack-plugin')\n     var env = config.build.env\n     \n     // 合并 webpack.base.conf.js\n     var webpackConfig = merge(baseWebpackConfig, {\n       module: {\n         // 使用的 loader\n         loaders: utils.styleLoaders({ sourceMap: config.build.productionSourceMap, extract: true })\n       },\n       // 是否使用 #source-map 开发工具，更多信息可以查看 DDFE 往期文章\n       devtool: config.build.productionSourceMap ? '#source-map' : false,\n       output: {\n         // 编译输出目录\n         path: config.build.assetsRoot,\n         // 编译输出文件名\n         // 我们可以在 hash 后加 :6 决定使用几位 hash 值\n         filename: utils.assetsPath('js/[name].[chunkhash].js'), \n         // 没有指定输出名的文件输出的文件名\n         chunkFilename: utils.assetsPath('js/[id].[chunkhash].js')\n       },\n       vue: {\n         // 编译 .vue 文件时使用的 loader\n         loaders: utils.cssLoaders({\n           sourceMap: config.build.productionSourceMap,\n           extract: true\n         })\n       },\n       plugins: [\n         // 使用的插件\n         // http://vuejs.github.io/vue-loader/en/workflow/production.html\n         // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串\n         new webpack.DefinePlugin({\n           'process.env': env\n         }),\n         // 压缩 js (同样可以压缩 css)\n         new webpack.optimize.UglifyJsPlugin({\n           compress: {\n             warnings: false\n           }\n         }),\n         new webpack.optimize.OccurrenceOrderPlugin(),\n         // extract css into its own file\n         // 将 css 文件分离出来\n         new ExtractTextPlugin(utils.assetsPath('css/[name].[contenthash].css')),\n         // generate dist index.html with correct asset hash for caching.\n         // you can customize output by editing /index.html\n         // see https://github.com/ampedandwired/html-webpack-plugin\n         // 输入输出的 .html 文件\n         new HtmlWebpackPlugin({\n           filename: config.build.index,\n           template: 'index.html',\n           // 是否注入 html\n           inject: true, \n           // 压缩的方式\n           minify: { \n             removeComments: true,\n             collapseWhitespace: true,\n             removeAttributeQuotes: true\n             // more options:\n             // https://github.com/kangax/html-minifier#options-quick-reference\n           },\n           // necessary to consistently work with multiple chunks via CommonsChunkPlugin\n           chunksSortMode: 'dependency'\n         }),\n         // split vendor js into its own file\n         // 没有指定输出文件名的文件输出的静态文件名\n         new webpack.optimize.CommonsChunkPlugin({\n           name: 'vendor',\n           minChunks: function (module, count) {\n             // any required modules inside node_modules are extracted to vendor\n             return (\n               module.resource &&\n               /\\.js$/.test(module.resource) &&\n               module.resource.indexOf(\n                 path.join(__dirname, '../node_modules')\n               ) === 0\n             )\n           }\n         }),\n         // extract webpack runtime and module manifest to its own file in order to\n         // prevent vendor hash from being updated whenever app bundle is updated\n         // 没有指定输出文件名的文件输出的静态文件名\n         new webpack.optimize.CommonsChunkPlugin({\n           name: 'manifest',\n           chunks: ['vendor']\n         })\n       ]\n     })\n     \n     // 开启 gzip 的情况下使用下方的配置\n     if (config.build.productionGzip) {\n       // 加载 compression-webpack-plugin 插件\n       var CompressionWebpackPlugin =  require('compression-webpack-plugin')\n       // 向webpackconfig.plugins中加入下方的插件\n       var reProductionGzipExtensions = '\\\\.(' + config.build.productionGzipExtensions.join('|') + '$)'\n       webpackConfig.plugins.push(\n         // 使用 compression-webpack-plugin 插件进行压缩\n         new CompressionWebpackPlugin({\n           asset: '[path].gz[query]',\n           algorithm: 'gzip',\n           test: new RegExp(reProductionGzipExtensions), // 注：此处因有代码格式化的bug，与源码有差异\n           threshold: 10240,\n           minRatio: 0.8\n         })\n       )\n     }\n     \n     module.exports = webpackConfig","slug":"vue-cli-2-中webpack的配置-一","published":1,"updated":"2018-09-14T16:38:30.818Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm28whma00067rs6rpkgrn75","content":"<p>这篇基本上转载自滴滴前端团队的一片文章,感谢这样优秀的前端团队.</p>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><pre><code>.\n├── README.md\n├── build\n│   ├── build.js\n│   ├── check-versions.js\n│   ├── dev-client.js\n│   ├── dev-server.js\n│   ├── utils.js\n│   ├── webpack.base.conf.js\n│   ├── webpack.dev.conf.js\n│   └── webpack.prod.conf.js\n├── config\n│   ├── dev.env.js\n│   ├── index.js\n│   └── prod.env.js\n├── index.html\n├── package.json\n├── src\n│   ├── App.vue\n│   ├── assets\n│   │   └── logo.png\n│   ├── components\n│   │   └── Hello.vue\n│   └── main.js\n└── static\n</code></pre><a id=\"more\"></a>    \n<h2 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h2><p>我们可以看到</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;node build/dev-server.js&quot;,\n    &quot;build&quot;: &quot;node build/build.js&quot;,\n    &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;\n}\n</code></pre><p>   当我们执行 npm run dev / npm run build 时运行的是 node build/dev-server.js 或 node build/build.js</p>\n<h2 id=\"dev-server-js\"><a href=\"#dev-server-js\" class=\"headerlink\" title=\"dev-server.js\"></a>dev-server.js</h2><pre><code>// 检查 Node 和 npm 版本\nrequire(&apos;./check-versions&apos;)()\n\n// 获取 config/index.js 的默认配置\nvar config = require(&apos;../config&apos;)\n\n// 如果 Node 的环境无法判断当前是 dev / product 环境\n// 使用 config.dev.env.NODE_ENV 作为当前的环境\n\nif (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)\n\n// 使用 NodeJS 自带的文件路径工具\nvar path = require(&apos;path&apos;)\n\n// 使用 express\nvar express = require(&apos;express&apos;)\n\n// 使用 webpack\nvar webpack = require(&apos;webpack&apos;)\n\n// 一个可以强制打开浏览器并跳转到指定 url 的插件\nvar opn = require(&apos;opn&apos;)\n\n// 使用 proxyTable\nvar proxyMiddleware = require(&apos;http-proxy-middleware&apos;)\n\n// 使用 dev 环境的 webpack 配置\nvar webpackConfig = require(&apos;./webpack.dev.conf&apos;)\n\n// default port where dev server listens for incoming traffic\n\n// 如果没有指定运行端口，使用 config.dev.port 作为运行端口\nvar port = process.env.PORT || config.dev.port\n\n// Define HTTP proxies to your custom API backend\n// https://github.com/chimurai/http-proxy-middleware\n\n// 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置\nvar proxyTable = config.dev.proxyTable\n\n// 使用 express 启动一个服务\nvar app = express()\n\n// 启动 webpack 进行编译\nvar compiler = webpack(webpackConfig)\n\n// 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中\nvar devMiddleware = require(&apos;webpack-dev-middleware&apos;)(compiler, {\n  publicPath: webpackConfig.output.publicPath,\n  stats: {\n    colors: true,\n    chunks: false\n  }\n})\n\n// 启动 webpack-hot-middleware，也就是我们常说的 Hot-reload\nvar hotMiddleware = require(&apos;webpack-hot-middleware&apos;)(compiler)\n// force page reload when html-webpack-plugin template changes\ncompiler.plugin(&apos;compilation&apos;, function (compilation) {\n  compilation.plugin(&apos;html-webpack-plugin-after-emit&apos;, function (data, cb) {\n    hotMiddleware.publish({ action: &apos;reload&apos; })\n    cb()\n  })\n})\n\n// proxy api requests\n// 将 proxyTable 中的请求配置挂在到启动的 express 服务上\nObject.keys(proxyTable).forEach(function (context) {\n  var options = proxyTable[context]\n  if (typeof options === &apos;string&apos;) {\n    options = { target: options }\n  }\n  app.use(proxyMiddleware(context, options))\n})\n\n// handle fallback for HTML5 history API\n// 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址\napp.use(require(&apos;connect-history-api-fallback&apos;)())\n\n// serve webpack bundle output\n// 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上\napp.use(devMiddleware)\n\n// enable hot-reload and state-preserving\n// compilation error display\n// 将 Hot-reload 挂在到 express 服务上\napp.use(hotMiddleware)\n\n// serve pure static assets\n// 拼接 static 文件夹的静态资源路径\nvar staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)\n// 为静态资源提供响应服务\napp.use(staticPath, express.static(&apos;./static&apos;))\n\n// 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露\nmodule.exports = app.listen(port, function (err) {\n  if (err) {\n    console.log(err)\n    return\n  }\n  var uri = &apos;http://localhost:&apos; + port\n  console.log(&apos;Listening at &apos; + uri + &apos;\\n&apos;)\n\n  // when env is testing, don&apos;t need open it\n  // 如果不是测试环境，自动打开浏览器并跳到我们的开发地址\n  if (process.env.NODE_ENV !== &apos;testing&apos;) {\n    opn(uri)\n  }\n})\n</code></pre><h2 id=\"webpack-dev-conf-js\"><a href=\"#webpack-dev-conf-js\" class=\"headerlink\" title=\"webpack.dev.conf.js\"></a>webpack.dev.conf.js</h2><pre><code>// 同样的使用了 config/index.js\nvar config = require(&apos;../config&apos;) \n\n// 使用 webpack\nvar webpack = require(&apos;webpack&apos;) \n\n// 使用 webpack 配置合并插件\nvar merge = require(&apos;webpack-merge&apos;) \n\n// 使用一些小工具\nvar utils = require(&apos;./utils&apos;) \n\n// 加载 webpack.base.conf\nvar baseWebpackConfig = require(&apos;./webpack.base.conf&apos;) \n\n// 使用 html-webpack-plugin 插件，这个插件可以帮我们自动生成 html 并且注入到 .html 文件中\nvar HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) \n\n// add hot-reload related code to entry chunks\n// 将 Hol-reload 相对路径添加到 webpack.base.conf 的 对应 entry 前\nObject.keys(baseWebpackConfig.entry).forEach(function (name) {\n  baseWebpackConfig.entry[name] = [&apos;./build/dev-client&apos;].concat(baseWebpackConfig.entry[name])\n})\n\n// 将我们 webpack.dev.conf.js 的配置和 webpack.base.conf.js 的配置合并\nmodule.exports = merge(baseWebpackConfig, {\n  module: {\n    // 使用 styleLoaders\n    loaders: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap })\n  },\n  // eval-source-map is faster for development\n  // 使用 #eval-source-map 模式作为开发工具，此配置可参考 DDFE 往期文章详细了解\n  devtool: &apos;#eval-source-map&apos;,\n  plugins: [\n\n    // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串\n    new webpack.DefinePlugin({\n      &apos;process.env&apos;: config.dev.env\n    }),\n    // https://github.com/glenjamin/webpack-hot-middleware#installation--usage\n    new webpack.optimize.OccurenceOrderPlugin(),\n\n    // HotModule 插件在页面进行变更的时候只会重回对应的页面模块，不会重绘整个 html 文件\n    new webpack.HotModuleReplacementPlugin(),\n\n    // 使用了 NoErrorsPlugin 后页面中的报错不会阻塞，但是会在编译结束后报错\n    new webpack.NoErrorsPlugin(),\n    // https://github.com/ampedandwired/html-webpack-plugin\n\n    // 将 index.html 作为入口，注入 html 代码后生成 index.html文件\n    new HtmlWebpackPlugin({\n      filename: &apos;index.html&apos;,\n      template: &apos;index.html&apos;,\n      inject: true\n    })\n  ]\n})\n</code></pre><h2 id=\"webpack-base-conf-js\"><a href=\"#webpack-base-conf-js\" class=\"headerlink\" title=\"webpack.base.conf.js\"></a>webpack.base.conf.js</h2><p>我们看到在 webpack.dev.conf.js 中又引入了 webpack.base.conf.js</p>\n<pre><code>// 使用 NodeJS 自带的文件路径插件\nvar path = require(&apos;path&apos;) \n\n// 引入 config/index.js\nvar config = require(&apos;../config&apos;) \n\n// 引入一些小工具\nvar utils = require(&apos;./utils&apos;) \n\n// 拼接我们的工作区路径为一个绝对路径\nvar projectRoot = path.resolve(__dirname, &apos;../&apos;) \n\n// 将 NodeJS 环境作为我们的编译环境\nvar env = process.env.NODE_ENV\n\n// check env &amp; config/index.js to decide weither to enable CSS Sourcemaps for the\n// various preprocessor loaders added to vue-loader at the end of this file\n\n// 是否在 dev 环境下开启 cssSourceMap ，在 config/index.js 中可配置\nvar cssSourceMapDev = (env === &apos;development&apos; &amp;&amp; config.dev.cssSourceMap)\n\n// 是否在 production 环境下开启 cssSourceMap ，在 config/index.js 中可配置\nvar cssSourceMapProd = (env === &apos;production&apos; &amp;&amp; config.build.productionSourceMap)\n\n// 最终是否使用 cssSourceMap\nvar useCssSourceMap = cssSourceMapDev || cssSourceMapProd\n\nmodule.exports = {\n  entry: {\n      // 编译文件入口\n    app: &apos;./src/main.js&apos; \n  },\n  output: {\n      // 编译输出的根路径\n    path: config.build.assetsRoot, \n    // 正式发布环境下编译输出的发布路径\n    publicPath: process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsPublicPath : config.dev.assetsPublicPath, \n    // 编译输出的文件名\n    filename: &apos;[name].js&apos; \n  },\n  resolve: {\n    // 自动补全的扩展名\n    extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.vue&apos;],\n    // 不进行自动补全或处理的文件或者文件夹\n    fallback: [path.join(__dirname, &apos;../node_modules&apos;)],\n    alias: {\n    // 默认路径代理，例如 import Vue from &apos;vue&apos;，会自动到 &apos;vue/dist/vue.common.js&apos;中寻找\n      &apos;vue&apos;: &apos;vue/dist/vue.common.js&apos;,\n      &apos;src&apos;: path.resolve(__dirname, &apos;../src&apos;),\n      &apos;assets&apos;: path.resolve(__dirname, &apos;../src/assets&apos;),\n      &apos;components&apos;: path.resolve(__dirname, &apos;../src/components&apos;)\n    }\n  },\n  resolveLoader: {\n    fallback: [path.join(__dirname, &apos;../node_modules&apos;)]\n  },\n  module: {\n    preLoaders: [\n      // 预处理的文件及使用的 loader\n      {\n        test: /\\.vue$/,\n        loader: &apos;eslint&apos;,\n        include: projectRoot,\n        exclude: /node_modules/\n      },\n      {\n        test: /\\.js$/,\n        loader: &apos;eslint&apos;,\n        include: projectRoot,\n        exclude: /node_modules/\n      }\n    ],\n    loaders: [\n      // 需要处理的文件及使用的 loader\n      {\n        test: /\\.vue$/,\n        loader: &apos;vue&apos;\n      },\n      {\n        test: /\\.js$/,\n        loader: &apos;babel&apos;,\n        include: projectRoot,\n        exclude: /node_modules/\n      },\n      {\n        test: /\\.json$/,\n        loader: &apos;json&apos;\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: &apos;url&apos;,\n        query: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;)\n        }\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: &apos;url&apos;,\n        query: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;)\n        }\n      }\n    ]\n  },\n  eslint: {\n    // eslint 代码检查配置工具\n    formatter: require(&apos;eslint-friendly-formatter&apos;)\n  },\n  vue: {\n    // .vue 文件配置 loader 及工具 (autoprefixer)\n    loaders: utils.cssLoaders({ sourceMap: useCssSourceMap }),\n    postcss: [\n      require(&apos;autoprefixer&apos;)({\n        browsers: [&apos;last 2 versions&apos;]\n      })\n    ]\n  }\n}    \n</code></pre><h2 id=\"config-index-js\"><a href=\"#config-index-js\" class=\"headerlink\" title=\"config/index.js\"></a>config/index.js</h2><p>终于分析完了 webpack.base.conf.js，来让我们看一下 config/index.js</p>\n<p>index.js 中有 dev 和 production 两种环境的配置 </p>\n<pre><code>// see http://vuejs-templates.github.io/webpack for documentation.\n// 不再重复介绍了 ...\nvar path = require(&apos;path&apos;)\n\nmodule.exports = {\n  // production 环境\n  build: { \n      // 使用 config/prod.env.js 中定义的编译环境\n    env: require(&apos;./prod.env&apos;), \n    index: path.resolve(__dirname, &apos;../dist/index.html&apos;), // 编译输入的 index.html 文件\n    // 编译输出的静态资源根路径\n    assetsRoot: path.resolve(__dirname, &apos;../dist&apos;), \n    // 编译输出的二级目录\n    assetsSubDirectory: &apos;static&apos;, \n    // 编译发布上线路径的根目录，可配置为资源服务器域名或 CDN 域名\n    assetsPublicPath: &apos;/&apos;, \n    // 是否开启 cssSourceMap\n    productionSourceMap: true, \n    // Gzip off by default as many popular static hosts such as\n    // Surge or Netlify already gzip all static assets for you.\n    // Before setting to `true`, make sure to:\n    // npm install --save-dev compression-webpack-plugin\n    // 是否开启 gzip\n    productionGzip: false, \n    // 需要使用 gzip 压缩的文件扩展名\n    productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;] \n  },\n  // dev 环境\n  dev: { \n      // 使用 config/dev.env.js 中定义的编译环境\n    env: require(&apos;./dev.env&apos;), \n    // 运行测试页面的端口\n    port: 8080, \n    // 编译输出的二级目录\n    assetsSubDirectory: &apos;static&apos;, \n    // 编译发布上线路径的根目录，可配置为资源服务器域名或 CDN 域名\n    assetsPublicPath: &apos;/&apos;, \n    // 需要 proxyTable 代理的接口（可跨域）\n    proxyTable: {}, \n    // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot;\n    // with this option, according to the CSS-Loader README\n    // (https://github.com/webpack/css-loader#sourcemaps)\n    // In our experience, they generally work as expected,\n    // just be aware of this issue when enabling this option.\n    // 是否开启 cssSourceMap\n    cssSourceMap: false \n  }\n}\n</code></pre><p>至此，我们的 npm run dev 命令就讲解完毕，</p>\n<p>下面让我们来看一看执行 npm run build 命令时发生了什么 </p>\n<h2 id=\"build-js\"><a href=\"#build-js\" class=\"headerlink\" title=\"build.js\"></a>build.js</h2><pre><code>// https://github.com/shelljs/shelljs\n\n// 检查 Node 和 npm 版本\nrequire(&apos;./check-versions&apos;)() \n\n// 使用了 shelljs 插件，可以让我们在 node 环境的 js 中使用 shell\nrequire(&apos;shelljs/global&apos;) \nenv.NODE_ENV = &apos;production&apos;\n\n// 不再赘述\nvar path = require(&apos;path&apos;) \n\n// 加载 config.js\nvar config = require(&apos;../config&apos;) \n\n// 一个很好看的 loading 插件\nvar ora = require(&apos;ora&apos;) \n\n// 加载 webpack\nvar webpack = require(&apos;webpack&apos;) \n\n// 加载 webpack.prod.conf\nvar webpackConfig = require(&apos;./webpack.prod.conf&apos;) \n\n//  输出提示信息 ～ 提示用户请在 http 服务下查看本页面，否则为空白页\nconsole.log(\n  &apos;  Tip:\\n&apos; +\n  &apos;  Built files are meant to be served over an HTTP server.\\n&apos; +\n  &apos;  Opening index.html over file:// won\\&apos;t work.\\n&apos;\n)\n\n// 使用 ora 打印出 loading + log\nvar spinner = ora(&apos;building for production...&apos;) \n// 开始 loading 动画\nspinner.start() \n\n// 拼接编译输出文件路径\nvar assetsPath = path.join(config.build.assetsRoot, config.build.assetsSubDirectory)\n// 删除这个文件夹 （递归删除）\nrm(&apos;-rf&apos;, assetsPath)\n// 创建此文件夹 \nmkdir(&apos;-p&apos;, assetsPath)\n// 复制 static 文件夹到我们的编译输出目录\ncp(&apos;-R&apos;, &apos;static/*&apos;, assetsPath)\n\n//  开始 webpack 的编译\nwebpack(webpackConfig, function (err, stats) {\n  // 编译成功的回调函数\n  spinner.stop()\n  if (err) throw err\n  process.stdout.write(stats.toString({\n    colors: true,\n    modules: false,\n    children: false,\n    chunks: false,\n    chunkModules: false\n  }) + &apos;\\n&apos;)\n})\n</code></pre><h2 id=\"webpack-prod-conf-js\"><a href=\"#webpack-prod-conf-js\" class=\"headerlink\" title=\"webpack.prod.conf.js\"></a>webpack.prod.conf.js</h2><pre><code>// 不再赘述\nvar path = require(&apos;path&apos;)\n\n// 加载 confi.index.js\nvar config = require(&apos;../config&apos;)\n\n// 使用一些小工具\nvar utils = require(&apos;./utils&apos;) \n\n// 加载 webpack\nvar webpack = require(&apos;webpack&apos;) \n\n// 加载 webpack 配置合并工具\nvar merge = require(&apos;webpack-merge&apos;) \n\n// 加载 webpack.base.conf.js\nvar baseWebpackConfig = require(&apos;./webpack.base.conf&apos;) \n\n// 一个 webpack 扩展，可以提取一些代码并且将它们和文件分离开\n// 如果我们想将 webpack 打包成一个文件 css js 分离开，那我们需要这个插件\nvar ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)\n\n// 一个可以插入 html 并且创建新的 .html 文件的插件\nvar HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)\nvar env = config.build.env\n\n// 合并 webpack.base.conf.js\nvar webpackConfig = merge(baseWebpackConfig, {\n  module: {\n    // 使用的 loader\n    loaders: utils.styleLoaders({ sourceMap: config.build.productionSourceMap, extract: true })\n  },\n  // 是否使用 #source-map 开发工具，更多信息可以查看 DDFE 往期文章\n  devtool: config.build.productionSourceMap ? &apos;#source-map&apos; : false,\n  output: {\n    // 编译输出目录\n    path: config.build.assetsRoot,\n    // 编译输出文件名\n    // 我们可以在 hash 后加 :6 决定使用几位 hash 值\n    filename: utils.assetsPath(&apos;js/[name].[chunkhash].js&apos;), \n    // 没有指定输出名的文件输出的文件名\n    chunkFilename: utils.assetsPath(&apos;js/[id].[chunkhash].js&apos;)\n  },\n  vue: {\n    // 编译 .vue 文件时使用的 loader\n    loaders: utils.cssLoaders({\n      sourceMap: config.build.productionSourceMap,\n      extract: true\n    })\n  },\n  plugins: [\n    // 使用的插件\n    // http://vuejs.github.io/vue-loader/en/workflow/production.html\n    // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串\n    new webpack.DefinePlugin({\n      &apos;process.env&apos;: env\n    }),\n    // 压缩 js (同样可以压缩 css)\n    new webpack.optimize.UglifyJsPlugin({\n      compress: {\n        warnings: false\n      }\n    }),\n    new webpack.optimize.OccurrenceOrderPlugin(),\n    // extract css into its own file\n    // 将 css 文件分离出来\n    new ExtractTextPlugin(utils.assetsPath(&apos;css/[name].[contenthash].css&apos;)),\n    // generate dist index.html with correct asset hash for caching.\n    // you can customize output by editing /index.html\n    // see https://github.com/ampedandwired/html-webpack-plugin\n    // 输入输出的 .html 文件\n    new HtmlWebpackPlugin({\n      filename: config.build.index,\n      template: &apos;index.html&apos;,\n      // 是否注入 html\n      inject: true, \n      // 压缩的方式\n      minify: { \n        removeComments: true,\n        collapseWhitespace: true,\n        removeAttributeQuotes: true\n        // more options:\n        // https://github.com/kangax/html-minifier#options-quick-reference\n      },\n      // necessary to consistently work with multiple chunks via CommonsChunkPlugin\n      chunksSortMode: &apos;dependency&apos;\n    }),\n    // split vendor js into its own file\n    // 没有指定输出文件名的文件输出的静态文件名\n    new webpack.optimize.CommonsChunkPlugin({\n      name: &apos;vendor&apos;,\n      minChunks: function (module, count) {\n        // any required modules inside node_modules are extracted to vendor\n        return (\n          module.resource &amp;&amp;\n          /\\.js$/.test(module.resource) &amp;&amp;\n          module.resource.indexOf(\n            path.join(__dirname, &apos;../node_modules&apos;)\n          ) === 0\n        )\n      }\n    }),\n    // extract webpack runtime and module manifest to its own file in order to\n    // prevent vendor hash from being updated whenever app bundle is updated\n    // 没有指定输出文件名的文件输出的静态文件名\n    new webpack.optimize.CommonsChunkPlugin({\n      name: &apos;manifest&apos;,\n      chunks: [&apos;vendor&apos;]\n    })\n  ]\n})\n\n// 开启 gzip 的情况下使用下方的配置\nif (config.build.productionGzip) {\n  // 加载 compression-webpack-plugin 插件\n  var CompressionWebpackPlugin =  require(&apos;compression-webpack-plugin&apos;)\n  // 向webpackconfig.plugins中加入下方的插件\n  var reProductionGzipExtensions = &apos;\\\\.(&apos; + config.build.productionGzipExtensions.join(&apos;|&apos;) + &apos;$)&apos;\n  webpackConfig.plugins.push(\n    // 使用 compression-webpack-plugin 插件进行压缩\n    new CompressionWebpackPlugin({\n      asset: &apos;[path].gz[query]&apos;,\n      algorithm: &apos;gzip&apos;,\n      test: new RegExp(reProductionGzipExtensions), // 注：此处因有代码格式化的bug，与源码有差异\n      threshold: 10240,\n      minRatio: 0.8\n    })\n  )\n}\n\nmodule.exports = webpackConfig\n</code></pre>","site":{"data":{}},"excerpt":"<p>这篇基本上转载自滴滴前端团队的一片文章,感谢这样优秀的前端团队.</p>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><pre><code>.\n├── README.md\n├── build\n│   ├── build.js\n│   ├── check-versions.js\n│   ├── dev-client.js\n│   ├── dev-server.js\n│   ├── utils.js\n│   ├── webpack.base.conf.js\n│   ├── webpack.dev.conf.js\n│   └── webpack.prod.conf.js\n├── config\n│   ├── dev.env.js\n│   ├── index.js\n│   └── prod.env.js\n├── index.html\n├── package.json\n├── src\n│   ├── App.vue\n│   ├── assets\n│   │   └── logo.png\n│   ├── components\n│   │   └── Hello.vue\n│   └── main.js\n└── static\n</code></pre>","more":"<h2 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h2><p>我们可以看到</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;node build/dev-server.js&quot;,\n    &quot;build&quot;: &quot;node build/build.js&quot;,\n    &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;\n}\n</code></pre><p>   当我们执行 npm run dev / npm run build 时运行的是 node build/dev-server.js 或 node build/build.js</p>\n<h2 id=\"dev-server-js\"><a href=\"#dev-server-js\" class=\"headerlink\" title=\"dev-server.js\"></a>dev-server.js</h2><pre><code>// 检查 Node 和 npm 版本\nrequire(&apos;./check-versions&apos;)()\n\n// 获取 config/index.js 的默认配置\nvar config = require(&apos;../config&apos;)\n\n// 如果 Node 的环境无法判断当前是 dev / product 环境\n// 使用 config.dev.env.NODE_ENV 作为当前的环境\n\nif (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)\n\n// 使用 NodeJS 自带的文件路径工具\nvar path = require(&apos;path&apos;)\n\n// 使用 express\nvar express = require(&apos;express&apos;)\n\n// 使用 webpack\nvar webpack = require(&apos;webpack&apos;)\n\n// 一个可以强制打开浏览器并跳转到指定 url 的插件\nvar opn = require(&apos;opn&apos;)\n\n// 使用 proxyTable\nvar proxyMiddleware = require(&apos;http-proxy-middleware&apos;)\n\n// 使用 dev 环境的 webpack 配置\nvar webpackConfig = require(&apos;./webpack.dev.conf&apos;)\n\n// default port where dev server listens for incoming traffic\n\n// 如果没有指定运行端口，使用 config.dev.port 作为运行端口\nvar port = process.env.PORT || config.dev.port\n\n// Define HTTP proxies to your custom API backend\n// https://github.com/chimurai/http-proxy-middleware\n\n// 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置\nvar proxyTable = config.dev.proxyTable\n\n// 使用 express 启动一个服务\nvar app = express()\n\n// 启动 webpack 进行编译\nvar compiler = webpack(webpackConfig)\n\n// 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中\nvar devMiddleware = require(&apos;webpack-dev-middleware&apos;)(compiler, {\n  publicPath: webpackConfig.output.publicPath,\n  stats: {\n    colors: true,\n    chunks: false\n  }\n})\n\n// 启动 webpack-hot-middleware，也就是我们常说的 Hot-reload\nvar hotMiddleware = require(&apos;webpack-hot-middleware&apos;)(compiler)\n// force page reload when html-webpack-plugin template changes\ncompiler.plugin(&apos;compilation&apos;, function (compilation) {\n  compilation.plugin(&apos;html-webpack-plugin-after-emit&apos;, function (data, cb) {\n    hotMiddleware.publish({ action: &apos;reload&apos; })\n    cb()\n  })\n})\n\n// proxy api requests\n// 将 proxyTable 中的请求配置挂在到启动的 express 服务上\nObject.keys(proxyTable).forEach(function (context) {\n  var options = proxyTable[context]\n  if (typeof options === &apos;string&apos;) {\n    options = { target: options }\n  }\n  app.use(proxyMiddleware(context, options))\n})\n\n// handle fallback for HTML5 history API\n// 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址\napp.use(require(&apos;connect-history-api-fallback&apos;)())\n\n// serve webpack bundle output\n// 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上\napp.use(devMiddleware)\n\n// enable hot-reload and state-preserving\n// compilation error display\n// 将 Hot-reload 挂在到 express 服务上\napp.use(hotMiddleware)\n\n// serve pure static assets\n// 拼接 static 文件夹的静态资源路径\nvar staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)\n// 为静态资源提供响应服务\napp.use(staticPath, express.static(&apos;./static&apos;))\n\n// 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露\nmodule.exports = app.listen(port, function (err) {\n  if (err) {\n    console.log(err)\n    return\n  }\n  var uri = &apos;http://localhost:&apos; + port\n  console.log(&apos;Listening at &apos; + uri + &apos;\\n&apos;)\n\n  // when env is testing, don&apos;t need open it\n  // 如果不是测试环境，自动打开浏览器并跳到我们的开发地址\n  if (process.env.NODE_ENV !== &apos;testing&apos;) {\n    opn(uri)\n  }\n})\n</code></pre><h2 id=\"webpack-dev-conf-js\"><a href=\"#webpack-dev-conf-js\" class=\"headerlink\" title=\"webpack.dev.conf.js\"></a>webpack.dev.conf.js</h2><pre><code>// 同样的使用了 config/index.js\nvar config = require(&apos;../config&apos;) \n\n// 使用 webpack\nvar webpack = require(&apos;webpack&apos;) \n\n// 使用 webpack 配置合并插件\nvar merge = require(&apos;webpack-merge&apos;) \n\n// 使用一些小工具\nvar utils = require(&apos;./utils&apos;) \n\n// 加载 webpack.base.conf\nvar baseWebpackConfig = require(&apos;./webpack.base.conf&apos;) \n\n// 使用 html-webpack-plugin 插件，这个插件可以帮我们自动生成 html 并且注入到 .html 文件中\nvar HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) \n\n// add hot-reload related code to entry chunks\n// 将 Hol-reload 相对路径添加到 webpack.base.conf 的 对应 entry 前\nObject.keys(baseWebpackConfig.entry).forEach(function (name) {\n  baseWebpackConfig.entry[name] = [&apos;./build/dev-client&apos;].concat(baseWebpackConfig.entry[name])\n})\n\n// 将我们 webpack.dev.conf.js 的配置和 webpack.base.conf.js 的配置合并\nmodule.exports = merge(baseWebpackConfig, {\n  module: {\n    // 使用 styleLoaders\n    loaders: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap })\n  },\n  // eval-source-map is faster for development\n  // 使用 #eval-source-map 模式作为开发工具，此配置可参考 DDFE 往期文章详细了解\n  devtool: &apos;#eval-source-map&apos;,\n  plugins: [\n\n    // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串\n    new webpack.DefinePlugin({\n      &apos;process.env&apos;: config.dev.env\n    }),\n    // https://github.com/glenjamin/webpack-hot-middleware#installation--usage\n    new webpack.optimize.OccurenceOrderPlugin(),\n\n    // HotModule 插件在页面进行变更的时候只会重回对应的页面模块，不会重绘整个 html 文件\n    new webpack.HotModuleReplacementPlugin(),\n\n    // 使用了 NoErrorsPlugin 后页面中的报错不会阻塞，但是会在编译结束后报错\n    new webpack.NoErrorsPlugin(),\n    // https://github.com/ampedandwired/html-webpack-plugin\n\n    // 将 index.html 作为入口，注入 html 代码后生成 index.html文件\n    new HtmlWebpackPlugin({\n      filename: &apos;index.html&apos;,\n      template: &apos;index.html&apos;,\n      inject: true\n    })\n  ]\n})\n</code></pre><h2 id=\"webpack-base-conf-js\"><a href=\"#webpack-base-conf-js\" class=\"headerlink\" title=\"webpack.base.conf.js\"></a>webpack.base.conf.js</h2><p>我们看到在 webpack.dev.conf.js 中又引入了 webpack.base.conf.js</p>\n<pre><code>// 使用 NodeJS 自带的文件路径插件\nvar path = require(&apos;path&apos;) \n\n// 引入 config/index.js\nvar config = require(&apos;../config&apos;) \n\n// 引入一些小工具\nvar utils = require(&apos;./utils&apos;) \n\n// 拼接我们的工作区路径为一个绝对路径\nvar projectRoot = path.resolve(__dirname, &apos;../&apos;) \n\n// 将 NodeJS 环境作为我们的编译环境\nvar env = process.env.NODE_ENV\n\n// check env &amp; config/index.js to decide weither to enable CSS Sourcemaps for the\n// various preprocessor loaders added to vue-loader at the end of this file\n\n// 是否在 dev 环境下开启 cssSourceMap ，在 config/index.js 中可配置\nvar cssSourceMapDev = (env === &apos;development&apos; &amp;&amp; config.dev.cssSourceMap)\n\n// 是否在 production 环境下开启 cssSourceMap ，在 config/index.js 中可配置\nvar cssSourceMapProd = (env === &apos;production&apos; &amp;&amp; config.build.productionSourceMap)\n\n// 最终是否使用 cssSourceMap\nvar useCssSourceMap = cssSourceMapDev || cssSourceMapProd\n\nmodule.exports = {\n  entry: {\n      // 编译文件入口\n    app: &apos;./src/main.js&apos; \n  },\n  output: {\n      // 编译输出的根路径\n    path: config.build.assetsRoot, \n    // 正式发布环境下编译输出的发布路径\n    publicPath: process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsPublicPath : config.dev.assetsPublicPath, \n    // 编译输出的文件名\n    filename: &apos;[name].js&apos; \n  },\n  resolve: {\n    // 自动补全的扩展名\n    extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.vue&apos;],\n    // 不进行自动补全或处理的文件或者文件夹\n    fallback: [path.join(__dirname, &apos;../node_modules&apos;)],\n    alias: {\n    // 默认路径代理，例如 import Vue from &apos;vue&apos;，会自动到 &apos;vue/dist/vue.common.js&apos;中寻找\n      &apos;vue&apos;: &apos;vue/dist/vue.common.js&apos;,\n      &apos;src&apos;: path.resolve(__dirname, &apos;../src&apos;),\n      &apos;assets&apos;: path.resolve(__dirname, &apos;../src/assets&apos;),\n      &apos;components&apos;: path.resolve(__dirname, &apos;../src/components&apos;)\n    }\n  },\n  resolveLoader: {\n    fallback: [path.join(__dirname, &apos;../node_modules&apos;)]\n  },\n  module: {\n    preLoaders: [\n      // 预处理的文件及使用的 loader\n      {\n        test: /\\.vue$/,\n        loader: &apos;eslint&apos;,\n        include: projectRoot,\n        exclude: /node_modules/\n      },\n      {\n        test: /\\.js$/,\n        loader: &apos;eslint&apos;,\n        include: projectRoot,\n        exclude: /node_modules/\n      }\n    ],\n    loaders: [\n      // 需要处理的文件及使用的 loader\n      {\n        test: /\\.vue$/,\n        loader: &apos;vue&apos;\n      },\n      {\n        test: /\\.js$/,\n        loader: &apos;babel&apos;,\n        include: projectRoot,\n        exclude: /node_modules/\n      },\n      {\n        test: /\\.json$/,\n        loader: &apos;json&apos;\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: &apos;url&apos;,\n        query: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;)\n        }\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: &apos;url&apos;,\n        query: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;)\n        }\n      }\n    ]\n  },\n  eslint: {\n    // eslint 代码检查配置工具\n    formatter: require(&apos;eslint-friendly-formatter&apos;)\n  },\n  vue: {\n    // .vue 文件配置 loader 及工具 (autoprefixer)\n    loaders: utils.cssLoaders({ sourceMap: useCssSourceMap }),\n    postcss: [\n      require(&apos;autoprefixer&apos;)({\n        browsers: [&apos;last 2 versions&apos;]\n      })\n    ]\n  }\n}    \n</code></pre><h2 id=\"config-index-js\"><a href=\"#config-index-js\" class=\"headerlink\" title=\"config/index.js\"></a>config/index.js</h2><p>终于分析完了 webpack.base.conf.js，来让我们看一下 config/index.js</p>\n<p>index.js 中有 dev 和 production 两种环境的配置 </p>\n<pre><code>// see http://vuejs-templates.github.io/webpack for documentation.\n// 不再重复介绍了 ...\nvar path = require(&apos;path&apos;)\n\nmodule.exports = {\n  // production 环境\n  build: { \n      // 使用 config/prod.env.js 中定义的编译环境\n    env: require(&apos;./prod.env&apos;), \n    index: path.resolve(__dirname, &apos;../dist/index.html&apos;), // 编译输入的 index.html 文件\n    // 编译输出的静态资源根路径\n    assetsRoot: path.resolve(__dirname, &apos;../dist&apos;), \n    // 编译输出的二级目录\n    assetsSubDirectory: &apos;static&apos;, \n    // 编译发布上线路径的根目录，可配置为资源服务器域名或 CDN 域名\n    assetsPublicPath: &apos;/&apos;, \n    // 是否开启 cssSourceMap\n    productionSourceMap: true, \n    // Gzip off by default as many popular static hosts such as\n    // Surge or Netlify already gzip all static assets for you.\n    // Before setting to `true`, make sure to:\n    // npm install --save-dev compression-webpack-plugin\n    // 是否开启 gzip\n    productionGzip: false, \n    // 需要使用 gzip 压缩的文件扩展名\n    productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;] \n  },\n  // dev 环境\n  dev: { \n      // 使用 config/dev.env.js 中定义的编译环境\n    env: require(&apos;./dev.env&apos;), \n    // 运行测试页面的端口\n    port: 8080, \n    // 编译输出的二级目录\n    assetsSubDirectory: &apos;static&apos;, \n    // 编译发布上线路径的根目录，可配置为资源服务器域名或 CDN 域名\n    assetsPublicPath: &apos;/&apos;, \n    // 需要 proxyTable 代理的接口（可跨域）\n    proxyTable: {}, \n    // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot;\n    // with this option, according to the CSS-Loader README\n    // (https://github.com/webpack/css-loader#sourcemaps)\n    // In our experience, they generally work as expected,\n    // just be aware of this issue when enabling this option.\n    // 是否开启 cssSourceMap\n    cssSourceMap: false \n  }\n}\n</code></pre><p>至此，我们的 npm run dev 命令就讲解完毕，</p>\n<p>下面让我们来看一看执行 npm run build 命令时发生了什么 </p>\n<h2 id=\"build-js\"><a href=\"#build-js\" class=\"headerlink\" title=\"build.js\"></a>build.js</h2><pre><code>// https://github.com/shelljs/shelljs\n\n// 检查 Node 和 npm 版本\nrequire(&apos;./check-versions&apos;)() \n\n// 使用了 shelljs 插件，可以让我们在 node 环境的 js 中使用 shell\nrequire(&apos;shelljs/global&apos;) \nenv.NODE_ENV = &apos;production&apos;\n\n// 不再赘述\nvar path = require(&apos;path&apos;) \n\n// 加载 config.js\nvar config = require(&apos;../config&apos;) \n\n// 一个很好看的 loading 插件\nvar ora = require(&apos;ora&apos;) \n\n// 加载 webpack\nvar webpack = require(&apos;webpack&apos;) \n\n// 加载 webpack.prod.conf\nvar webpackConfig = require(&apos;./webpack.prod.conf&apos;) \n\n//  输出提示信息 ～ 提示用户请在 http 服务下查看本页面，否则为空白页\nconsole.log(\n  &apos;  Tip:\\n&apos; +\n  &apos;  Built files are meant to be served over an HTTP server.\\n&apos; +\n  &apos;  Opening index.html over file:// won\\&apos;t work.\\n&apos;\n)\n\n// 使用 ora 打印出 loading + log\nvar spinner = ora(&apos;building for production...&apos;) \n// 开始 loading 动画\nspinner.start() \n\n// 拼接编译输出文件路径\nvar assetsPath = path.join(config.build.assetsRoot, config.build.assetsSubDirectory)\n// 删除这个文件夹 （递归删除）\nrm(&apos;-rf&apos;, assetsPath)\n// 创建此文件夹 \nmkdir(&apos;-p&apos;, assetsPath)\n// 复制 static 文件夹到我们的编译输出目录\ncp(&apos;-R&apos;, &apos;static/*&apos;, assetsPath)\n\n//  开始 webpack 的编译\nwebpack(webpackConfig, function (err, stats) {\n  // 编译成功的回调函数\n  spinner.stop()\n  if (err) throw err\n  process.stdout.write(stats.toString({\n    colors: true,\n    modules: false,\n    children: false,\n    chunks: false,\n    chunkModules: false\n  }) + &apos;\\n&apos;)\n})\n</code></pre><h2 id=\"webpack-prod-conf-js\"><a href=\"#webpack-prod-conf-js\" class=\"headerlink\" title=\"webpack.prod.conf.js\"></a>webpack.prod.conf.js</h2><pre><code>// 不再赘述\nvar path = require(&apos;path&apos;)\n\n// 加载 confi.index.js\nvar config = require(&apos;../config&apos;)\n\n// 使用一些小工具\nvar utils = require(&apos;./utils&apos;) \n\n// 加载 webpack\nvar webpack = require(&apos;webpack&apos;) \n\n// 加载 webpack 配置合并工具\nvar merge = require(&apos;webpack-merge&apos;) \n\n// 加载 webpack.base.conf.js\nvar baseWebpackConfig = require(&apos;./webpack.base.conf&apos;) \n\n// 一个 webpack 扩展，可以提取一些代码并且将它们和文件分离开\n// 如果我们想将 webpack 打包成一个文件 css js 分离开，那我们需要这个插件\nvar ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)\n\n// 一个可以插入 html 并且创建新的 .html 文件的插件\nvar HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)\nvar env = config.build.env\n\n// 合并 webpack.base.conf.js\nvar webpackConfig = merge(baseWebpackConfig, {\n  module: {\n    // 使用的 loader\n    loaders: utils.styleLoaders({ sourceMap: config.build.productionSourceMap, extract: true })\n  },\n  // 是否使用 #source-map 开发工具，更多信息可以查看 DDFE 往期文章\n  devtool: config.build.productionSourceMap ? &apos;#source-map&apos; : false,\n  output: {\n    // 编译输出目录\n    path: config.build.assetsRoot,\n    // 编译输出文件名\n    // 我们可以在 hash 后加 :6 决定使用几位 hash 值\n    filename: utils.assetsPath(&apos;js/[name].[chunkhash].js&apos;), \n    // 没有指定输出名的文件输出的文件名\n    chunkFilename: utils.assetsPath(&apos;js/[id].[chunkhash].js&apos;)\n  },\n  vue: {\n    // 编译 .vue 文件时使用的 loader\n    loaders: utils.cssLoaders({\n      sourceMap: config.build.productionSourceMap,\n      extract: true\n    })\n  },\n  plugins: [\n    // 使用的插件\n    // http://vuejs.github.io/vue-loader/en/workflow/production.html\n    // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串\n    new webpack.DefinePlugin({\n      &apos;process.env&apos;: env\n    }),\n    // 压缩 js (同样可以压缩 css)\n    new webpack.optimize.UglifyJsPlugin({\n      compress: {\n        warnings: false\n      }\n    }),\n    new webpack.optimize.OccurrenceOrderPlugin(),\n    // extract css into its own file\n    // 将 css 文件分离出来\n    new ExtractTextPlugin(utils.assetsPath(&apos;css/[name].[contenthash].css&apos;)),\n    // generate dist index.html with correct asset hash for caching.\n    // you can customize output by editing /index.html\n    // see https://github.com/ampedandwired/html-webpack-plugin\n    // 输入输出的 .html 文件\n    new HtmlWebpackPlugin({\n      filename: config.build.index,\n      template: &apos;index.html&apos;,\n      // 是否注入 html\n      inject: true, \n      // 压缩的方式\n      minify: { \n        removeComments: true,\n        collapseWhitespace: true,\n        removeAttributeQuotes: true\n        // more options:\n        // https://github.com/kangax/html-minifier#options-quick-reference\n      },\n      // necessary to consistently work with multiple chunks via CommonsChunkPlugin\n      chunksSortMode: &apos;dependency&apos;\n    }),\n    // split vendor js into its own file\n    // 没有指定输出文件名的文件输出的静态文件名\n    new webpack.optimize.CommonsChunkPlugin({\n      name: &apos;vendor&apos;,\n      minChunks: function (module, count) {\n        // any required modules inside node_modules are extracted to vendor\n        return (\n          module.resource &amp;&amp;\n          /\\.js$/.test(module.resource) &amp;&amp;\n          module.resource.indexOf(\n            path.join(__dirname, &apos;../node_modules&apos;)\n          ) === 0\n        )\n      }\n    }),\n    // extract webpack runtime and module manifest to its own file in order to\n    // prevent vendor hash from being updated whenever app bundle is updated\n    // 没有指定输出文件名的文件输出的静态文件名\n    new webpack.optimize.CommonsChunkPlugin({\n      name: &apos;manifest&apos;,\n      chunks: [&apos;vendor&apos;]\n    })\n  ]\n})\n\n// 开启 gzip 的情况下使用下方的配置\nif (config.build.productionGzip) {\n  // 加载 compression-webpack-plugin 插件\n  var CompressionWebpackPlugin =  require(&apos;compression-webpack-plugin&apos;)\n  // 向webpackconfig.plugins中加入下方的插件\n  var reProductionGzipExtensions = &apos;\\\\.(&apos; + config.build.productionGzipExtensions.join(&apos;|&apos;) + &apos;$)&apos;\n  webpackConfig.plugins.push(\n    // 使用 compression-webpack-plugin 插件进行压缩\n    new CompressionWebpackPlugin({\n      asset: &apos;[path].gz[query]&apos;,\n      algorithm: &apos;gzip&apos;,\n      test: new RegExp(reProductionGzipExtensions), // 注：此处因有代码格式化的bug，与源码有差异\n      threshold: 10240,\n      minRatio: 0.8\n    })\n  )\n}\n\nmodule.exports = webpackConfig\n</code></pre>"},{"title":"vue-cli中process.env.NODE_ENV","date":"2017-10-08T09:25:32.000Z","_content":"看前面vue-cli讲解的文章,对process.env.NODE_ENV,一直不理解是怎么设置的,怎么就变成production或者development\n    \n    // webpack.base.config.js\n    output: {\n        path: config.build.assetsRoot,\n        filename: '[name].js',\n        publicPath: process.env.NODE_ENV === 'production'\n          ? config.build.assetsPublicPath\n          : config.dev.assetsPublicPath\n      },\n      \n      \n通过看了不同的文章,大概有所了解.\n\n请参考[process.env](http://cnodejs.org/topic/57a409657a922d6f358cd22d)\n\n[改变运行脚本的环境变量](http://blog.404mzk.com/%E5%8C%BA%E5%88%86%E6%B5%8B%E8%AF%95%E5%92%8C%E6%AD%A3%E5%BC%8F%E7%8E%AF%E5%A2%83.html)\n\n[业务代码如何判断生产/开发环境](http://array_huang.coding.me/webpack-book/chapter2/webpack-dev-production-environment.html)        \n\n[DefinePlugin中的淫技巧](http://blog.csdn.net/sinat_17775997/article/details/70140322)\n\n<!-- more -->        \n\n### process.env\nprocess对象用于处理与当前进程相关的事情，它是一个全局对象，可以在任何地方直接访问到它而无需引入额外模块。 它是 EventEmitter 的一个实例。\n\nprocess.env 获取当前系统环境信息的对象，常规可以用来进一步获取环境变量、用户名等系统信息：\n\n    console.log(process.env);\n    console.log('username: ' + process.env.USERNAME);\n    console.log('PATH: ' + process.env.PATH);\n\n### webpack 开发和生产的区别\n开发环境(development)和生产环境(production)的构建目标差异很大。\n\n在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。\n\n而在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。\n\n由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置。\n\n分别为\n\nwebpack.config.js\n\nwebpack.dev.js\n\nwebpack.production.js\n\n### 如何区分生产环境还是开发环境\n引入process.env，这样就可以在业务代码中靠process.env.NODE_ENV来判断.\n\n在webpack.base.config.js区分process.env.NODE_ENV来决定设置webpack配置为开发还是生产.\n    \n        // webpack.base.config.js\n        output: {\n            path: config.build.assetsRoot,\n            filename: '[name].js',\n            publicPath: process.env.NODE_ENV === 'production'\n              ? config.build.assetsPublicPath\n              : config.dev.assetsPublicPath\n          },\n \n      \n###  process.env.NODE_ENV如何设置 \n\n1. 因为process是nodejs全局变量,可以通过命令行设置\n        \n        \n        export NODE_ENV = production && webpack\n        \n        export NODE_ENV = dev && webpack\n        \n2. 也可以通过package.json设置\n        \n        \n            {\n              \"scripts\": {\n                \"dev\": \"export NODE_ENV=dev&&webpack  --progress --colors\",\n                \"production\": \"export NODE_ENV=production&&webpack  --progress --colors\",\n              },\n\n3. 也可以借助webpack.DefinePlugin插件,在代码里面设置,如\n          \n             \n                //webpack.dev.js\n             plugins: [\n                new webpack.DefinePlugin({\n                  'process.env': config.dev.env\n                }),\n             \n             //config/index.js\n             dev: {\n                 env: require('./dev.env'),\n                 port: 8080,\n    \n            //config/dev.env.js\n            var merge = require('webpack-merge')\n            var prodEnv = require('./prod.env')\n            \n            module.exports = merge(prodEnv, {\n              NODE_ENV: '\"development\"'\n            })\n\n但是在build.js中  process.env.NODE_ENV = 'production'  ,不知道这个和webpack.prod.js里面的有什么区别.\n     ","source":"_posts/vue-cli中process-env-NODE-ENV.md","raw":"---\ntitle: vue-cli中process.env.NODE_ENV\ndate: 2017-10-08 17:25:32\ntags: [ vue-cli, webpack,nodejs] \ncategories: [front]\n---\n看前面vue-cli讲解的文章,对process.env.NODE_ENV,一直不理解是怎么设置的,怎么就变成production或者development\n    \n    // webpack.base.config.js\n    output: {\n        path: config.build.assetsRoot,\n        filename: '[name].js',\n        publicPath: process.env.NODE_ENV === 'production'\n          ? config.build.assetsPublicPath\n          : config.dev.assetsPublicPath\n      },\n      \n      \n通过看了不同的文章,大概有所了解.\n\n请参考[process.env](http://cnodejs.org/topic/57a409657a922d6f358cd22d)\n\n[改变运行脚本的环境变量](http://blog.404mzk.com/%E5%8C%BA%E5%88%86%E6%B5%8B%E8%AF%95%E5%92%8C%E6%AD%A3%E5%BC%8F%E7%8E%AF%E5%A2%83.html)\n\n[业务代码如何判断生产/开发环境](http://array_huang.coding.me/webpack-book/chapter2/webpack-dev-production-environment.html)        \n\n[DefinePlugin中的淫技巧](http://blog.csdn.net/sinat_17775997/article/details/70140322)\n\n<!-- more -->        \n\n### process.env\nprocess对象用于处理与当前进程相关的事情，它是一个全局对象，可以在任何地方直接访问到它而无需引入额外模块。 它是 EventEmitter 的一个实例。\n\nprocess.env 获取当前系统环境信息的对象，常规可以用来进一步获取环境变量、用户名等系统信息：\n\n    console.log(process.env);\n    console.log('username: ' + process.env.USERNAME);\n    console.log('PATH: ' + process.env.PATH);\n\n### webpack 开发和生产的区别\n开发环境(development)和生产环境(production)的构建目标差异很大。\n\n在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。\n\n而在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。\n\n由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置。\n\n分别为\n\nwebpack.config.js\n\nwebpack.dev.js\n\nwebpack.production.js\n\n### 如何区分生产环境还是开发环境\n引入process.env，这样就可以在业务代码中靠process.env.NODE_ENV来判断.\n\n在webpack.base.config.js区分process.env.NODE_ENV来决定设置webpack配置为开发还是生产.\n    \n        // webpack.base.config.js\n        output: {\n            path: config.build.assetsRoot,\n            filename: '[name].js',\n            publicPath: process.env.NODE_ENV === 'production'\n              ? config.build.assetsPublicPath\n              : config.dev.assetsPublicPath\n          },\n \n      \n###  process.env.NODE_ENV如何设置 \n\n1. 因为process是nodejs全局变量,可以通过命令行设置\n        \n        \n        export NODE_ENV = production && webpack\n        \n        export NODE_ENV = dev && webpack\n        \n2. 也可以通过package.json设置\n        \n        \n            {\n              \"scripts\": {\n                \"dev\": \"export NODE_ENV=dev&&webpack  --progress --colors\",\n                \"production\": \"export NODE_ENV=production&&webpack  --progress --colors\",\n              },\n\n3. 也可以借助webpack.DefinePlugin插件,在代码里面设置,如\n          \n             \n                //webpack.dev.js\n             plugins: [\n                new webpack.DefinePlugin({\n                  'process.env': config.dev.env\n                }),\n             \n             //config/index.js\n             dev: {\n                 env: require('./dev.env'),\n                 port: 8080,\n    \n            //config/dev.env.js\n            var merge = require('webpack-merge')\n            var prodEnv = require('./prod.env')\n            \n            module.exports = merge(prodEnv, {\n              NODE_ENV: '\"development\"'\n            })\n\n但是在build.js中  process.env.NODE_ENV = 'production'  ,不知道这个和webpack.prod.js里面的有什么区别.\n     ","slug":"vue-cli中process-env-NODE-ENV","published":1,"updated":"2018-09-14T16:38:30.818Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm28whmd00097rs60ceuz6rj","content":"<p>看前面vue-cli讲解的文章,对process.env.NODE_ENV,一直不理解是怎么设置的,怎么就变成production或者development</p>\n<pre><code>// webpack.base.config.js\noutput: {\n    path: config.build.assetsRoot,\n    filename: &apos;[name].js&apos;,\n    publicPath: process.env.NODE_ENV === &apos;production&apos;\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath\n  },\n</code></pre><p>通过看了不同的文章,大概有所了解.</p>\n<p>请参考<a href=\"http://cnodejs.org/topic/57a409657a922d6f358cd22d\" target=\"_blank\" rel=\"noopener\">process.env</a></p>\n<p><a href=\"http://blog.404mzk.com/%E5%8C%BA%E5%88%86%E6%B5%8B%E8%AF%95%E5%92%8C%E6%AD%A3%E5%BC%8F%E7%8E%AF%E5%A2%83.html\" target=\"_blank\" rel=\"noopener\">改变运行脚本的环境变量</a></p>\n<p><a href=\"http://array_huang.coding.me/webpack-book/chapter2/webpack-dev-production-environment.html\" target=\"_blank\" rel=\"noopener\">业务代码如何判断生产/开发环境</a>        </p>\n<p><a href=\"http://blog.csdn.net/sinat_17775997/article/details/70140322\" target=\"_blank\" rel=\"noopener\">DefinePlugin中的淫技巧</a></p>\n<a id=\"more\"></a>        \n<h3 id=\"process-env\"><a href=\"#process-env\" class=\"headerlink\" title=\"process.env\"></a>process.env</h3><p>process对象用于处理与当前进程相关的事情，它是一个全局对象，可以在任何地方直接访问到它而无需引入额外模块。 它是 EventEmitter 的一个实例。</p>\n<p>process.env 获取当前系统环境信息的对象，常规可以用来进一步获取环境变量、用户名等系统信息：</p>\n<pre><code>console.log(process.env);\nconsole.log(&apos;username: &apos; + process.env.USERNAME);\nconsole.log(&apos;PATH: &apos; + process.env.PATH);\n</code></pre><h3 id=\"webpack-开发和生产的区别\"><a href=\"#webpack-开发和生产的区别\" class=\"headerlink\" title=\"webpack 开发和生产的区别\"></a>webpack 开发和生产的区别</h3><p>开发环境(development)和生产环境(production)的构建目标差异很大。</p>\n<p>在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。</p>\n<p>而在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。</p>\n<p>由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置。</p>\n<p>分别为</p>\n<p>webpack.config.js</p>\n<p>webpack.dev.js</p>\n<p>webpack.production.js</p>\n<h3 id=\"如何区分生产环境还是开发环境\"><a href=\"#如何区分生产环境还是开发环境\" class=\"headerlink\" title=\"如何区分生产环境还是开发环境\"></a>如何区分生产环境还是开发环境</h3><p>引入process.env，这样就可以在业务代码中靠process.env.NODE_ENV来判断.</p>\n<p>在webpack.base.config.js区分process.env.NODE_ENV来决定设置webpack配置为开发还是生产.</p>\n<pre><code>// webpack.base.config.js\noutput: {\n    path: config.build.assetsRoot,\n    filename: &apos;[name].js&apos;,\n    publicPath: process.env.NODE_ENV === &apos;production&apos;\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath\n  },\n</code></pre><h3 id=\"process-env-NODE-ENV如何设置\"><a href=\"#process-env-NODE-ENV如何设置\" class=\"headerlink\" title=\"process.env.NODE_ENV如何设置\"></a>process.env.NODE_ENV如何设置</h3><ol>\n<li>因为process是nodejs全局变量,可以通过命令行设置</li>\n</ol>\n<pre><code>export NODE_ENV = production &amp;&amp; webpack\n\nexport NODE_ENV = dev &amp;&amp; webpack\n</code></pre><ol start=\"2\">\n<li>也可以通过package.json设置</li>\n</ol>\n<pre><code>{\n  &quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;export NODE_ENV=dev&amp;&amp;webpack  --progress --colors&quot;,\n    &quot;production&quot;: &quot;export NODE_ENV=production&amp;&amp;webpack  --progress --colors&quot;,\n  },\n</code></pre><ol start=\"3\">\n<li>也可以借助webpack.DefinePlugin插件,在代码里面设置,如</li>\n</ol>\n<pre><code>    //webpack.dev.js\n plugins: [\n    new webpack.DefinePlugin({\n      &apos;process.env&apos;: config.dev.env\n    }),\n\n //config/index.js\n dev: {\n     env: require(&apos;./dev.env&apos;),\n     port: 8080,\n\n//config/dev.env.js\nvar merge = require(&apos;webpack-merge&apos;)\nvar prodEnv = require(&apos;./prod.env&apos;)\n\nmodule.exports = merge(prodEnv, {\n  NODE_ENV: &apos;&quot;development&quot;&apos;\n})\n</code></pre><p>但是在build.js中  process.env.NODE_ENV = ‘production’  ,不知道这个和webpack.prod.js里面的有什么区别.</p>\n","site":{"data":{}},"excerpt":"<p>看前面vue-cli讲解的文章,对process.env.NODE_ENV,一直不理解是怎么设置的,怎么就变成production或者development</p>\n<pre><code>// webpack.base.config.js\noutput: {\n    path: config.build.assetsRoot,\n    filename: &apos;[name].js&apos;,\n    publicPath: process.env.NODE_ENV === &apos;production&apos;\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath\n  },\n</code></pre><p>通过看了不同的文章,大概有所了解.</p>\n<p>请参考<a href=\"http://cnodejs.org/topic/57a409657a922d6f358cd22d\" target=\"_blank\" rel=\"noopener\">process.env</a></p>\n<p><a href=\"http://blog.404mzk.com/%E5%8C%BA%E5%88%86%E6%B5%8B%E8%AF%95%E5%92%8C%E6%AD%A3%E5%BC%8F%E7%8E%AF%E5%A2%83.html\" target=\"_blank\" rel=\"noopener\">改变运行脚本的环境变量</a></p>\n<p><a href=\"http://array_huang.coding.me/webpack-book/chapter2/webpack-dev-production-environment.html\" target=\"_blank\" rel=\"noopener\">业务代码如何判断生产/开发环境</a>        </p>\n<p><a href=\"http://blog.csdn.net/sinat_17775997/article/details/70140322\" target=\"_blank\" rel=\"noopener\">DefinePlugin中的淫技巧</a></p>","more":"<h3 id=\"process-env\"><a href=\"#process-env\" class=\"headerlink\" title=\"process.env\"></a>process.env</h3><p>process对象用于处理与当前进程相关的事情，它是一个全局对象，可以在任何地方直接访问到它而无需引入额外模块。 它是 EventEmitter 的一个实例。</p>\n<p>process.env 获取当前系统环境信息的对象，常规可以用来进一步获取环境变量、用户名等系统信息：</p>\n<pre><code>console.log(process.env);\nconsole.log(&apos;username: &apos; + process.env.USERNAME);\nconsole.log(&apos;PATH: &apos; + process.env.PATH);\n</code></pre><h3 id=\"webpack-开发和生产的区别\"><a href=\"#webpack-开发和生产的区别\" class=\"headerlink\" title=\"webpack 开发和生产的区别\"></a>webpack 开发和生产的区别</h3><p>开发环境(development)和生产环境(production)的构建目标差异很大。</p>\n<p>在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。</p>\n<p>而在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。</p>\n<p>由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置。</p>\n<p>分别为</p>\n<p>webpack.config.js</p>\n<p>webpack.dev.js</p>\n<p>webpack.production.js</p>\n<h3 id=\"如何区分生产环境还是开发环境\"><a href=\"#如何区分生产环境还是开发环境\" class=\"headerlink\" title=\"如何区分生产环境还是开发环境\"></a>如何区分生产环境还是开发环境</h3><p>引入process.env，这样就可以在业务代码中靠process.env.NODE_ENV来判断.</p>\n<p>在webpack.base.config.js区分process.env.NODE_ENV来决定设置webpack配置为开发还是生产.</p>\n<pre><code>// webpack.base.config.js\noutput: {\n    path: config.build.assetsRoot,\n    filename: &apos;[name].js&apos;,\n    publicPath: process.env.NODE_ENV === &apos;production&apos;\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath\n  },\n</code></pre><h3 id=\"process-env-NODE-ENV如何设置\"><a href=\"#process-env-NODE-ENV如何设置\" class=\"headerlink\" title=\"process.env.NODE_ENV如何设置\"></a>process.env.NODE_ENV如何设置</h3><ol>\n<li>因为process是nodejs全局变量,可以通过命令行设置</li>\n</ol>\n<pre><code>export NODE_ENV = production &amp;&amp; webpack\n\nexport NODE_ENV = dev &amp;&amp; webpack\n</code></pre><ol start=\"2\">\n<li>也可以通过package.json设置</li>\n</ol>\n<pre><code>{\n  &quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;export NODE_ENV=dev&amp;&amp;webpack  --progress --colors&quot;,\n    &quot;production&quot;: &quot;export NODE_ENV=production&amp;&amp;webpack  --progress --colors&quot;,\n  },\n</code></pre><ol start=\"3\">\n<li>也可以借助webpack.DefinePlugin插件,在代码里面设置,如</li>\n</ol>\n<pre><code>    //webpack.dev.js\n plugins: [\n    new webpack.DefinePlugin({\n      &apos;process.env&apos;: config.dev.env\n    }),\n\n //config/index.js\n dev: {\n     env: require(&apos;./dev.env&apos;),\n     port: 8080,\n\n//config/dev.env.js\nvar merge = require(&apos;webpack-merge&apos;)\nvar prodEnv = require(&apos;./prod.env&apos;)\n\nmodule.exports = merge(prodEnv, {\n  NODE_ENV: &apos;&quot;development&quot;&apos;\n})\n</code></pre><p>但是在build.js中  process.env.NODE_ENV = ‘production’  ,不知道这个和webpack.prod.js里面的有什么区别.</p>"},{"title":"vue-cli编译打包后起node服务测试","date":"2017-10-08T06:37:32.000Z","_content":"使用vue-cli开发项目中,一直使用dev-server.js这个本地服务,实现从内存中读取文件.\n\n项目完成后,要编译打包生成打包文件,提示不能通过打开file//方式访问,需要另外起服务访问.\n\n但是打包好后,不可能立即放到真实服务器中,还需要通过在本地测试一下,故另开一个node服务.\n\n### 原因\n因为打包后生成的文件如script/link等路径都是绝对路径,当然找不到了.\n\n### 解决1 修改配置\n如果弄明白vue-cli中webpack的配置,下面这个肯定明白,就是把绝对路径形式改成相对路径,但是不知道对放到真实服务器上有没影响.\n<!-- more -->        \n\n       这里有一个万能解决办法：\n           1. 将config/index.js 里面的 assetsPublicPath:'/' 改为assetsPublicPath:'./'  \n           2. build/util.js里面的\n           if (options.extract) {\n                     return ExtractTextPlugin.extract({\n                                   use: loaders,\n                                   fallback: 'vue-style-loader',\n                                   publicPath:'/'\n           })\n           将其中的publicPath改为：publicPath：'../../'就可以了。这样打包出来的路径就是正确的了。\n       \n           第一个是为了改变js中引入图片的路径，改为./ 就是指在当前路径，这个.代表的路径就是assetsRoot+assetsSubDictionary，我这里定位到dist/static/ ，加上图片前缀img，就可以找到了。\n           第二种是为了改变vue文件中使用style样式里面例如background:url('xxx')，这样的路径，因为style最终变成css文件在dist/static/css里面，我们的图片放在dist/static/img中，那么加上../../变成dist目录下，默认的目录前缀是static，img是图片默认前缀，这样就可以定位到图片。\n\n\n### 解决2 起一个node服务,并定位静态资源入口\n1.新建build/prod-server.js\n    \n    var express = require('express')\n    \n    var app = express()\n    var opn = require('opn')\n    var path = require('path')\n    \n    var distPath = path.join(__dirname,\"../dist\");\n    //静态资源目录入口\n    app.use(express.static(distPath));\n    \n    module.exports = app.listen(8081, function (err) {\n        if (err) {\n            console.log(err)\n            return\n        }\n        var uri = 'http://localhost:' + 8081+\"/\"\n        console.log('Listening at ' + uri + '\\n')\n        opn(uri)\n    })\n\n直接在项目目录命令行运行 node  prod-server.js  就可以访问了\n\n2 也可以在package.json中设置\n\n        \"scripts\": {\n            \"dev\": \"node build/dev-server.js\",\n            \"build\": \"node build/build.js\",\n            \"local-server\": \"node build/prod-server.js\"\n          },\n          \n这样也可以直接  npm run local-server             ","source":"_posts/vue-cli编译打包后起node服务测试.md","raw":"---\ntitle: vue-cli编译打包后起node服务测试\ndate: 2017-10-08 14:37:32\ntags: [webpack,vue-cli,node,vue] \ncategories: [front]\n---\n使用vue-cli开发项目中,一直使用dev-server.js这个本地服务,实现从内存中读取文件.\n\n项目完成后,要编译打包生成打包文件,提示不能通过打开file//方式访问,需要另外起服务访问.\n\n但是打包好后,不可能立即放到真实服务器中,还需要通过在本地测试一下,故另开一个node服务.\n\n### 原因\n因为打包后生成的文件如script/link等路径都是绝对路径,当然找不到了.\n\n### 解决1 修改配置\n如果弄明白vue-cli中webpack的配置,下面这个肯定明白,就是把绝对路径形式改成相对路径,但是不知道对放到真实服务器上有没影响.\n<!-- more -->        \n\n       这里有一个万能解决办法：\n           1. 将config/index.js 里面的 assetsPublicPath:'/' 改为assetsPublicPath:'./'  \n           2. build/util.js里面的\n           if (options.extract) {\n                     return ExtractTextPlugin.extract({\n                                   use: loaders,\n                                   fallback: 'vue-style-loader',\n                                   publicPath:'/'\n           })\n           将其中的publicPath改为：publicPath：'../../'就可以了。这样打包出来的路径就是正确的了。\n       \n           第一个是为了改变js中引入图片的路径，改为./ 就是指在当前路径，这个.代表的路径就是assetsRoot+assetsSubDictionary，我这里定位到dist/static/ ，加上图片前缀img，就可以找到了。\n           第二种是为了改变vue文件中使用style样式里面例如background:url('xxx')，这样的路径，因为style最终变成css文件在dist/static/css里面，我们的图片放在dist/static/img中，那么加上../../变成dist目录下，默认的目录前缀是static，img是图片默认前缀，这样就可以定位到图片。\n\n\n### 解决2 起一个node服务,并定位静态资源入口\n1.新建build/prod-server.js\n    \n    var express = require('express')\n    \n    var app = express()\n    var opn = require('opn')\n    var path = require('path')\n    \n    var distPath = path.join(__dirname,\"../dist\");\n    //静态资源目录入口\n    app.use(express.static(distPath));\n    \n    module.exports = app.listen(8081, function (err) {\n        if (err) {\n            console.log(err)\n            return\n        }\n        var uri = 'http://localhost:' + 8081+\"/\"\n        console.log('Listening at ' + uri + '\\n')\n        opn(uri)\n    })\n\n直接在项目目录命令行运行 node  prod-server.js  就可以访问了\n\n2 也可以在package.json中设置\n\n        \"scripts\": {\n            \"dev\": \"node build/dev-server.js\",\n            \"build\": \"node build/build.js\",\n            \"local-server\": \"node build/prod-server.js\"\n          },\n          \n这样也可以直接  npm run local-server             ","slug":"vue-cli编译打包后起node服务测试","published":1,"updated":"2018-09-14T16:38:30.818Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm28whme000a7rs6g1klc05e","content":"<p>使用vue-cli开发项目中,一直使用dev-server.js这个本地服务,实现从内存中读取文件.</p>\n<p>项目完成后,要编译打包生成打包文件,提示不能通过打开file//方式访问,需要另外起服务访问.</p>\n<p>但是打包好后,不可能立即放到真实服务器中,还需要通过在本地测试一下,故另开一个node服务.</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>因为打包后生成的文件如script/link等路径都是绝对路径,当然找不到了.</p>\n<h3 id=\"解决1-修改配置\"><a href=\"#解决1-修改配置\" class=\"headerlink\" title=\"解决1 修改配置\"></a>解决1 修改配置</h3><p>如果弄明白vue-cli中webpack的配置,下面这个肯定明白,就是把绝对路径形式改成相对路径,但是不知道对放到真实服务器上有没影响.<br><a id=\"more\"></a>        </p>\n<pre><code>这里有一个万能解决办法：\n    1. 将config/index.js 里面的 assetsPublicPath:&apos;/&apos; 改为assetsPublicPath:&apos;./&apos;  \n    2. build/util.js里面的\n    if (options.extract) {\n              return ExtractTextPlugin.extract({\n                            use: loaders,\n                            fallback: &apos;vue-style-loader&apos;,\n                            publicPath:&apos;/&apos;\n    })\n    将其中的publicPath改为：publicPath：&apos;../../&apos;就可以了。这样打包出来的路径就是正确的了。\n\n    第一个是为了改变js中引入图片的路径，改为./ 就是指在当前路径，这个.代表的路径就是assetsRoot+assetsSubDictionary，我这里定位到dist/static/ ，加上图片前缀img，就可以找到了。\n    第二种是为了改变vue文件中使用style样式里面例如background:url(&apos;xxx&apos;)，这样的路径，因为style最终变成css文件在dist/static/css里面，我们的图片放在dist/static/img中，那么加上../../变成dist目录下，默认的目录前缀是static，img是图片默认前缀，这样就可以定位到图片。\n</code></pre><h3 id=\"解决2-起一个node服务-并定位静态资源入口\"><a href=\"#解决2-起一个node服务-并定位静态资源入口\" class=\"headerlink\" title=\"解决2 起一个node服务,并定位静态资源入口\"></a>解决2 起一个node服务,并定位静态资源入口</h3><p>1.新建build/prod-server.js</p>\n<pre><code>var express = require(&apos;express&apos;)\n\nvar app = express()\nvar opn = require(&apos;opn&apos;)\nvar path = require(&apos;path&apos;)\n\nvar distPath = path.join(__dirname,&quot;../dist&quot;);\n//静态资源目录入口\napp.use(express.static(distPath));\n\nmodule.exports = app.listen(8081, function (err) {\n    if (err) {\n        console.log(err)\n        return\n    }\n    var uri = &apos;http://localhost:&apos; + 8081+&quot;/&quot;\n    console.log(&apos;Listening at &apos; + uri + &apos;\\n&apos;)\n    opn(uri)\n})\n</code></pre><p>直接在项目目录命令行运行 node  prod-server.js  就可以访问了</p>\n<p>2 也可以在package.json中设置</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;node build/dev-server.js&quot;,\n    &quot;build&quot;: &quot;node build/build.js&quot;,\n    &quot;local-server&quot;: &quot;node build/prod-server.js&quot;\n  },\n</code></pre><p>这样也可以直接  npm run local-server             </p>\n","site":{"data":{}},"excerpt":"<p>使用vue-cli开发项目中,一直使用dev-server.js这个本地服务,实现从内存中读取文件.</p>\n<p>项目完成后,要编译打包生成打包文件,提示不能通过打开file//方式访问,需要另外起服务访问.</p>\n<p>但是打包好后,不可能立即放到真实服务器中,还需要通过在本地测试一下,故另开一个node服务.</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>因为打包后生成的文件如script/link等路径都是绝对路径,当然找不到了.</p>\n<h3 id=\"解决1-修改配置\"><a href=\"#解决1-修改配置\" class=\"headerlink\" title=\"解决1 修改配置\"></a>解决1 修改配置</h3><p>如果弄明白vue-cli中webpack的配置,下面这个肯定明白,就是把绝对路径形式改成相对路径,但是不知道对放到真实服务器上有没影响.<br>","more":"</p>\n<pre><code>这里有一个万能解决办法：\n    1. 将config/index.js 里面的 assetsPublicPath:&apos;/&apos; 改为assetsPublicPath:&apos;./&apos;  \n    2. build/util.js里面的\n    if (options.extract) {\n              return ExtractTextPlugin.extract({\n                            use: loaders,\n                            fallback: &apos;vue-style-loader&apos;,\n                            publicPath:&apos;/&apos;\n    })\n    将其中的publicPath改为：publicPath：&apos;../../&apos;就可以了。这样打包出来的路径就是正确的了。\n\n    第一个是为了改变js中引入图片的路径，改为./ 就是指在当前路径，这个.代表的路径就是assetsRoot+assetsSubDictionary，我这里定位到dist/static/ ，加上图片前缀img，就可以找到了。\n    第二种是为了改变vue文件中使用style样式里面例如background:url(&apos;xxx&apos;)，这样的路径，因为style最终变成css文件在dist/static/css里面，我们的图片放在dist/static/img中，那么加上../../变成dist目录下，默认的目录前缀是static，img是图片默认前缀，这样就可以定位到图片。\n</code></pre><h3 id=\"解决2-起一个node服务-并定位静态资源入口\"><a href=\"#解决2-起一个node服务-并定位静态资源入口\" class=\"headerlink\" title=\"解决2 起一个node服务,并定位静态资源入口\"></a>解决2 起一个node服务,并定位静态资源入口</h3><p>1.新建build/prod-server.js</p>\n<pre><code>var express = require(&apos;express&apos;)\n\nvar app = express()\nvar opn = require(&apos;opn&apos;)\nvar path = require(&apos;path&apos;)\n\nvar distPath = path.join(__dirname,&quot;../dist&quot;);\n//静态资源目录入口\napp.use(express.static(distPath));\n\nmodule.exports = app.listen(8081, function (err) {\n    if (err) {\n        console.log(err)\n        return\n    }\n    var uri = &apos;http://localhost:&apos; + 8081+&quot;/&quot;\n    console.log(&apos;Listening at &apos; + uri + &apos;\\n&apos;)\n    opn(uri)\n})\n</code></pre><p>直接在项目目录命令行运行 node  prod-server.js  就可以访问了</p>\n<p>2 也可以在package.json中设置</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;node build/dev-server.js&quot;,\n    &quot;build&quot;: &quot;node build/build.js&quot;,\n    &quot;local-server&quot;: &quot;node build/prod-server.js&quot;\n  },\n</code></pre><p>这样也可以直接  npm run local-server             </p>"},{"title":"vue开发跨域解决办法","date":"2017-10-15T06:58:20.000Z","_content":"# 跨域\n\n是前端开发绕不开的一个话题,尤其在前后端分离的大趋势下,更加变得家常便饭,比如vue本地开发,调用接口,就要跨域.\n\n前面几篇文章,也有所设计跨域相关指示,这里总结一下,前端使用vue开发解决跨域的问题.\n\n1.因为跨域是浏览器的安全策略,在chorme浏览器中,可以在快捷图标中设置 --disable-web-security,非常方便.但是在最新chorme中还要稍加复杂的设置.\n<!--more-->\n2.使用chorme插件[Allow-Control-Allow-Origin](https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?utm_source=chrome-app-launcher-info-dialog),需要翻墙,实际用起来,效果还不错.偶尔失效.\n\n3.使用jsonp ,前面有文章[jsonp使用及promise封装](https://killerlei.github.io./2017/10/05/jsonp%E4%BD%BF%E7%94%A8%E5%8F%8Apromise%E5%B0%81%E8%A3%85/).\n\n4.使用node代理,如[使用代理解决跨域限制](https://killerlei.github.io./2017/10/06/%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%99%90%E5%88%B6/)\n\n5.使用vue-cli中配置的插件webpack-dev-middleware,实现代理.这要是本文要写的.原理同4,都是使用nodejs做个代理,只是过程不同.\n\ndev.server.js\n\n    var devMiddleware = require('webpack-dev-middleware')(compiler, {\n    publicPath: webpackConfig.output.publicPath,\n        stats: {\n            colors: true,\n            chunks: false\n        }\n    })\n    // proxy api requests\n    Object.keys(proxyTable).forEach(function (context) {\n        var options = proxyTable[context]\n        if (typeof options === 'string') {\n            options = { target: options }\n        }\n        app.use(proxyMiddleware(context, options))\n    })\n\nconfig/index.js\n\n    dev: {\n        env: require('./dev.env'),\n        port: 8081,\n        assetsSubDirectory: 'static',\n        assetsPublicPath: '/',\n        /*assetsSubDirectory: '/xxxxx',\n        assetsPublicPath: '',*/\n        proxyTable: proxyConfig.proxyList,\n        cssSourceMap: false\n     }\n\nconfig/proxyConfig.js\n\n    module.exports = {\n                        proxyList: {\n                                '/apiDev': {\n                                    //真实跨域接口\n                                    target: 'http://xxxxx.com',\n                                    changeOrigin: true,\n                                    pathRewrite: {\n                                        '^/apiDev': ''\n                                    }\n                                }\n                        }\n    }\n在开发中使用接口如 /apiDev/getAll,会被代理到http://xxxxx.com/getAll.\n\n开发完成后,要上测试或者生产,在换成http://xxxxx.com/getAll. 这部分也可以通过配置实现自动切换,以后会写到.","source":"_posts/vue开发跨域解决办法.md","raw":"---\ntitle: vue开发跨域解决办法\ndate: 2017-10-15 14:58:20\ntags: [跨域, 代理] \ncategories: [front]\n---\n# 跨域\n\n是前端开发绕不开的一个话题,尤其在前后端分离的大趋势下,更加变得家常便饭,比如vue本地开发,调用接口,就要跨域.\n\n前面几篇文章,也有所设计跨域相关指示,这里总结一下,前端使用vue开发解决跨域的问题.\n\n1.因为跨域是浏览器的安全策略,在chorme浏览器中,可以在快捷图标中设置 --disable-web-security,非常方便.但是在最新chorme中还要稍加复杂的设置.\n<!--more-->\n2.使用chorme插件[Allow-Control-Allow-Origin](https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?utm_source=chrome-app-launcher-info-dialog),需要翻墙,实际用起来,效果还不错.偶尔失效.\n\n3.使用jsonp ,前面有文章[jsonp使用及promise封装](https://killerlei.github.io./2017/10/05/jsonp%E4%BD%BF%E7%94%A8%E5%8F%8Apromise%E5%B0%81%E8%A3%85/).\n\n4.使用node代理,如[使用代理解决跨域限制](https://killerlei.github.io./2017/10/06/%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%99%90%E5%88%B6/)\n\n5.使用vue-cli中配置的插件webpack-dev-middleware,实现代理.这要是本文要写的.原理同4,都是使用nodejs做个代理,只是过程不同.\n\ndev.server.js\n\n    var devMiddleware = require('webpack-dev-middleware')(compiler, {\n    publicPath: webpackConfig.output.publicPath,\n        stats: {\n            colors: true,\n            chunks: false\n        }\n    })\n    // proxy api requests\n    Object.keys(proxyTable).forEach(function (context) {\n        var options = proxyTable[context]\n        if (typeof options === 'string') {\n            options = { target: options }\n        }\n        app.use(proxyMiddleware(context, options))\n    })\n\nconfig/index.js\n\n    dev: {\n        env: require('./dev.env'),\n        port: 8081,\n        assetsSubDirectory: 'static',\n        assetsPublicPath: '/',\n        /*assetsSubDirectory: '/xxxxx',\n        assetsPublicPath: '',*/\n        proxyTable: proxyConfig.proxyList,\n        cssSourceMap: false\n     }\n\nconfig/proxyConfig.js\n\n    module.exports = {\n                        proxyList: {\n                                '/apiDev': {\n                                    //真实跨域接口\n                                    target: 'http://xxxxx.com',\n                                    changeOrigin: true,\n                                    pathRewrite: {\n                                        '^/apiDev': ''\n                                    }\n                                }\n                        }\n    }\n在开发中使用接口如 /apiDev/getAll,会被代理到http://xxxxx.com/getAll.\n\n开发完成后,要上测试或者生产,在换成http://xxxxx.com/getAll. 这部分也可以通过配置实现自动切换,以后会写到.","slug":"vue开发跨域解决办法","published":1,"updated":"2018-09-14T16:38:30.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm28whmf000e7rs6e0y4m1j8","content":"<h1 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h1><p>是前端开发绕不开的一个话题,尤其在前后端分离的大趋势下,更加变得家常便饭,比如vue本地开发,调用接口,就要跨域.</p>\n<p>前面几篇文章,也有所设计跨域相关指示,这里总结一下,前端使用vue开发解决跨域的问题.</p>\n<p>1.因为跨域是浏览器的安全策略,在chorme浏览器中,可以在快捷图标中设置 –disable-web-security,非常方便.但是在最新chorme中还要稍加复杂的设置.<br><a id=\"more\"></a><br>2.使用chorme插件<a href=\"https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?utm_source=chrome-app-launcher-info-dialog\" target=\"_blank\" rel=\"noopener\">Allow-Control-Allow-Origin</a>,需要翻墙,实际用起来,效果还不错.偶尔失效.</p>\n<p>3.使用jsonp ,前面有文章<a href=\"https://killerlei.github.io./2017/10/05/jsonp%E4%BD%BF%E7%94%A8%E5%8F%8Apromise%E5%B0%81%E8%A3%85/\" target=\"_blank\" rel=\"noopener\">jsonp使用及promise封装</a>.</p>\n<p>4.使用node代理,如<a href=\"https://killerlei.github.io./2017/10/06/%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%99%90%E5%88%B6/\" target=\"_blank\" rel=\"noopener\">使用代理解决跨域限制</a></p>\n<p>5.使用vue-cli中配置的插件webpack-dev-middleware,实现代理.这要是本文要写的.原理同4,都是使用nodejs做个代理,只是过程不同.</p>\n<p>dev.server.js</p>\n<pre><code>var devMiddleware = require(&apos;webpack-dev-middleware&apos;)(compiler, {\npublicPath: webpackConfig.output.publicPath,\n    stats: {\n        colors: true,\n        chunks: false\n    }\n})\n// proxy api requests\nObject.keys(proxyTable).forEach(function (context) {\n    var options = proxyTable[context]\n    if (typeof options === &apos;string&apos;) {\n        options = { target: options }\n    }\n    app.use(proxyMiddleware(context, options))\n})\n</code></pre><p>config/index.js</p>\n<pre><code>dev: {\n    env: require(&apos;./dev.env&apos;),\n    port: 8081,\n    assetsSubDirectory: &apos;static&apos;,\n    assetsPublicPath: &apos;/&apos;,\n    /*assetsSubDirectory: &apos;/xxxxx&apos;,\n    assetsPublicPath: &apos;&apos;,*/\n    proxyTable: proxyConfig.proxyList,\n    cssSourceMap: false\n }\n</code></pre><p>config/proxyConfig.js</p>\n<pre><code>module.exports = {\n                    proxyList: {\n                            &apos;/apiDev&apos;: {\n                                //真实跨域接口\n                                target: &apos;http://xxxxx.com&apos;,\n                                changeOrigin: true,\n                                pathRewrite: {\n                                    &apos;^/apiDev&apos;: &apos;&apos;\n                                }\n                            }\n                    }\n}\n</code></pre><p>在开发中使用接口如 /apiDev/getAll,会被代理到<a href=\"http://xxxxx.com/getAll\" target=\"_blank\" rel=\"noopener\">http://xxxxx.com/getAll</a>.</p>\n<p>开发完成后,要上测试或者生产,在换成<a href=\"http://xxxxx.com/getAll\" target=\"_blank\" rel=\"noopener\">http://xxxxx.com/getAll</a>. 这部分也可以通过配置实现自动切换,以后会写到.</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h1><p>是前端开发绕不开的一个话题,尤其在前后端分离的大趋势下,更加变得家常便饭,比如vue本地开发,调用接口,就要跨域.</p>\n<p>前面几篇文章,也有所设计跨域相关指示,这里总结一下,前端使用vue开发解决跨域的问题.</p>\n<p>1.因为跨域是浏览器的安全策略,在chorme浏览器中,可以在快捷图标中设置 –disable-web-security,非常方便.但是在最新chorme中还要稍加复杂的设置.<br>","more":"<br>2.使用chorme插件<a href=\"https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?utm_source=chrome-app-launcher-info-dialog\" target=\"_blank\" rel=\"noopener\">Allow-Control-Allow-Origin</a>,需要翻墙,实际用起来,效果还不错.偶尔失效.</p>\n<p>3.使用jsonp ,前面有文章<a href=\"https://killerlei.github.io./2017/10/05/jsonp%E4%BD%BF%E7%94%A8%E5%8F%8Apromise%E5%B0%81%E8%A3%85/\" target=\"_blank\" rel=\"noopener\">jsonp使用及promise封装</a>.</p>\n<p>4.使用node代理,如<a href=\"https://killerlei.github.io./2017/10/06/%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%99%90%E5%88%B6/\" target=\"_blank\" rel=\"noopener\">使用代理解决跨域限制</a></p>\n<p>5.使用vue-cli中配置的插件webpack-dev-middleware,实现代理.这要是本文要写的.原理同4,都是使用nodejs做个代理,只是过程不同.</p>\n<p>dev.server.js</p>\n<pre><code>var devMiddleware = require(&apos;webpack-dev-middleware&apos;)(compiler, {\npublicPath: webpackConfig.output.publicPath,\n    stats: {\n        colors: true,\n        chunks: false\n    }\n})\n// proxy api requests\nObject.keys(proxyTable).forEach(function (context) {\n    var options = proxyTable[context]\n    if (typeof options === &apos;string&apos;) {\n        options = { target: options }\n    }\n    app.use(proxyMiddleware(context, options))\n})\n</code></pre><p>config/index.js</p>\n<pre><code>dev: {\n    env: require(&apos;./dev.env&apos;),\n    port: 8081,\n    assetsSubDirectory: &apos;static&apos;,\n    assetsPublicPath: &apos;/&apos;,\n    /*assetsSubDirectory: &apos;/xxxxx&apos;,\n    assetsPublicPath: &apos;&apos;,*/\n    proxyTable: proxyConfig.proxyList,\n    cssSourceMap: false\n }\n</code></pre><p>config/proxyConfig.js</p>\n<pre><code>module.exports = {\n                    proxyList: {\n                            &apos;/apiDev&apos;: {\n                                //真实跨域接口\n                                target: &apos;http://xxxxx.com&apos;,\n                                changeOrigin: true,\n                                pathRewrite: {\n                                    &apos;^/apiDev&apos;: &apos;&apos;\n                                }\n                            }\n                    }\n}\n</code></pre><p>在开发中使用接口如 /apiDev/getAll,会被代理到<a href=\"http://xxxxx.com/getAll\" target=\"_blank\" rel=\"noopener\">http://xxxxx.com/getAll</a>.</p>\n<p>开发完成后,要上测试或者生产,在换成<a href=\"http://xxxxx.com/getAll\" target=\"_blank\" rel=\"noopener\">http://xxxxx.com/getAll</a>. 这部分也可以通过配置实现自动切换,以后会写到.</p>"},{"title":"webpack总结(一)","date":"2017-10-07T04:24:53.000Z","_content":"# 前言\n\n作为一个前端开发者,现在已经不可避免的要和webpack打交道了,尤其使用vuejs以后,项目上不可避免要使用集成webpack的vue-cli.\n\nvue-cli基本上已经配置好了相关的webpack配置,基本上就可以开发了,不用开发人员再配置webpack,省时省力.\n\n但是webpack还是要弄清除基本的配置,尤其在面试的时候不可避免被问到,我在网上看到好多讲解的文章,受益匪浅,但是总是看时明白,过两天就忘记了,望而复始,所以想总结一下,以便能有个地方可以随时查阅,下面会引用别人的文章,以及自己的理解,肯定会有错误之处,请多对比.\n\n# webpack特点\n\n是一个模块打包工具,不同于gulp,gulp只是一个构建工具,只执行相应的任务,比如说压缩/合并/检查/自动刷新等等,替代了人工操作,提高了开发人员的工作效率而已,不会对项目结构有所影响.\n\nwebpack会把js/css/image/html等文件都视作模块,根据模块依赖关系进行静态分析,然后将这些模块按照指定的规则生成对应的静态资源.不仅仅可以执行压缩/合并等任务,还会深度参与项目结构.而且可以根据需求生成多个打包js,可以异步加载,实现按需加载.\n\n两个特点:\n1. 一切皆模块\n\n2. 按需加载\n\n# webpack基本配置\n\n可以子命令行执行  webpack .........来打包\n\n一般专门配置webpack.config.js来方便的只在命令行执行webpack来打包.\n\n实际开发中一般又分成webpack.dev.config.js和webpack.build.config.js,还可能有webpack.test.config.js.具体可以参考vue-cli,后面在具体讲解.\n\n\n    const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm\n    const webpack = require('webpack'); //to access built-in plugins\n    const path = require('path');\n    \n    const config = {\n      entry: './path/to/my/entry/file.js',\n      output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'my-first-webpack.bundle.js'\n      },\n      module: {\n        rules: [\n          {test: /\\.(js|jsx)$/, loader: 'babel-loader'}\n        ]\n      },\n      plugins: [\n        new webpack.optimize.UglifyJsPlugin(),\n        new HtmlWebpackPlugin({template: './src/index.html'})\n      ]\n    };\n    \n    module.exports = config;\n\n这是一个简单的示例,还有其他配置选项,下面一个一个来介绍.(因为webpack2配置方面有点改变比如,loader->rules等等,可能下面的会有所冲突)\n<!-- more -->\n## 生成source Maps(调试用)\n需要在配置中设置\ndevtool:'source-map'  (总共有七个选项,不同选项,打包速度也快,但也越不利于调试,调试也是各坑,有的选项打不上断点或者断点在下一行)\n    \n## 构建本地服务器\n只从有了nodejs以后,前端就可以用node在本地起服务,而不用在配置java服务.\n而且webpack也是基于nodejs的.\n\n1.npm 安装webpack-dev-server,这是一个基于express的webpack服务.\n\n2.在配置中\n    \n        devServer:{\n            contentBase:'./dist',\n            colors:true,\n            historyApiFallback:true,\n            inline:true\n        }\n\n## loaders \n   通过不同的loader,对各种文件进行处理\n   1. 安装\n   2. 在配置的modules属性下进行配置\n           \n            \n      module: {\n          rules: [\n            {\n              test: /\\.(js|vue)$/,\n              loader: 'eslint-loader',\n              enforce: 'pre',\n              include: [resolve('src'), resolve('test')],\n              options: {\n                formatter: require('eslint-friendly-formatter')\n              }\n            },\n            {\n              test: /\\.vue$/,\n              loader: 'vue-loader',\n              options: vueLoaderConfig\n            },\n            {\n              test: /\\.js$/,\n              loader: 'babel-loader',\n              include: [resolve('src'), resolve('test')]\n            },\n            {\n              test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n              loader: 'url-loader',\n              options: {\n                limit: 10000,\n                name: utils.assetsPath('img/[name].[hash:7].[ext]')\n              }\n            },\n            {\n              test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n              loader: 'url-loader',\n              options: {\n                limit: 10000,\n                name: utils.assetsPath('media/[name].[hash:7].[ext]')\n              }\n            },\n            {\n              test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n              loader: 'url-loader',\n              options: {\n                limit: 10000,\n                name: utils.assetsPath('fonts/[name].[hash:7].[ext]')\n              }\n            }\n          ]\n        }\n            \n   必选属性:\n   \n   test: 匹配要处理的文件扩展名(正则表达式)\n   \n   loader而: 加载器\n   \n   可选属性:\n   \n   include: 手动添加必须处理的文件(文件夹)\n   exclude: 手动屏蔽不需要处理的文件(文件夹)\n      \n   query: 提供额外的处置选项,也可以直接写在loader里(webpack2应该是改成options,如上面的配置)\n   \n   \n        {test:/\\.png|jpe?g|ico$/,\n         loader:'url-loader',\n         exclude:'/node-modles/',(举例而已,实际没有)\n         query:{\n            limited:10000,\n            name: '[name].[ext]?[hash]'\n         }\n        }\n        \n        \n## bable \n将ES6转化为ES5的包,会有好几个包,核心功能在bable-core这个包中\n用的最多的是解析ES6的babel-prsent-es2015和解析jsx的bable-present-react\n配置如下:\n  \n  \n      loaders:[{\n        test:/\\.js$/,\n        exclude:'/node_modules',\n        laoder:'babel',\n        query:{\n            presets:['es2015','react']\n        }\n      }]\n      \nbable还有非常的配置选项,实际一般把配置选项放到'bablerc'这个单独的文件中,webpack会自动调用.","source":"_posts/webpack总结-一.md","raw":"---\ntitle: webpack总结(一)\ndate: 2017-10-07 12:24:53\ntags: [webpack] \ncategories: [front]\n---\n# 前言\n\n作为一个前端开发者,现在已经不可避免的要和webpack打交道了,尤其使用vuejs以后,项目上不可避免要使用集成webpack的vue-cli.\n\nvue-cli基本上已经配置好了相关的webpack配置,基本上就可以开发了,不用开发人员再配置webpack,省时省力.\n\n但是webpack还是要弄清除基本的配置,尤其在面试的时候不可避免被问到,我在网上看到好多讲解的文章,受益匪浅,但是总是看时明白,过两天就忘记了,望而复始,所以想总结一下,以便能有个地方可以随时查阅,下面会引用别人的文章,以及自己的理解,肯定会有错误之处,请多对比.\n\n# webpack特点\n\n是一个模块打包工具,不同于gulp,gulp只是一个构建工具,只执行相应的任务,比如说压缩/合并/检查/自动刷新等等,替代了人工操作,提高了开发人员的工作效率而已,不会对项目结构有所影响.\n\nwebpack会把js/css/image/html等文件都视作模块,根据模块依赖关系进行静态分析,然后将这些模块按照指定的规则生成对应的静态资源.不仅仅可以执行压缩/合并等任务,还会深度参与项目结构.而且可以根据需求生成多个打包js,可以异步加载,实现按需加载.\n\n两个特点:\n1. 一切皆模块\n\n2. 按需加载\n\n# webpack基本配置\n\n可以子命令行执行  webpack .........来打包\n\n一般专门配置webpack.config.js来方便的只在命令行执行webpack来打包.\n\n实际开发中一般又分成webpack.dev.config.js和webpack.build.config.js,还可能有webpack.test.config.js.具体可以参考vue-cli,后面在具体讲解.\n\n\n    const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm\n    const webpack = require('webpack'); //to access built-in plugins\n    const path = require('path');\n    \n    const config = {\n      entry: './path/to/my/entry/file.js',\n      output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'my-first-webpack.bundle.js'\n      },\n      module: {\n        rules: [\n          {test: /\\.(js|jsx)$/, loader: 'babel-loader'}\n        ]\n      },\n      plugins: [\n        new webpack.optimize.UglifyJsPlugin(),\n        new HtmlWebpackPlugin({template: './src/index.html'})\n      ]\n    };\n    \n    module.exports = config;\n\n这是一个简单的示例,还有其他配置选项,下面一个一个来介绍.(因为webpack2配置方面有点改变比如,loader->rules等等,可能下面的会有所冲突)\n<!-- more -->\n## 生成source Maps(调试用)\n需要在配置中设置\ndevtool:'source-map'  (总共有七个选项,不同选项,打包速度也快,但也越不利于调试,调试也是各坑,有的选项打不上断点或者断点在下一行)\n    \n## 构建本地服务器\n只从有了nodejs以后,前端就可以用node在本地起服务,而不用在配置java服务.\n而且webpack也是基于nodejs的.\n\n1.npm 安装webpack-dev-server,这是一个基于express的webpack服务.\n\n2.在配置中\n    \n        devServer:{\n            contentBase:'./dist',\n            colors:true,\n            historyApiFallback:true,\n            inline:true\n        }\n\n## loaders \n   通过不同的loader,对各种文件进行处理\n   1. 安装\n   2. 在配置的modules属性下进行配置\n           \n            \n      module: {\n          rules: [\n            {\n              test: /\\.(js|vue)$/,\n              loader: 'eslint-loader',\n              enforce: 'pre',\n              include: [resolve('src'), resolve('test')],\n              options: {\n                formatter: require('eslint-friendly-formatter')\n              }\n            },\n            {\n              test: /\\.vue$/,\n              loader: 'vue-loader',\n              options: vueLoaderConfig\n            },\n            {\n              test: /\\.js$/,\n              loader: 'babel-loader',\n              include: [resolve('src'), resolve('test')]\n            },\n            {\n              test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n              loader: 'url-loader',\n              options: {\n                limit: 10000,\n                name: utils.assetsPath('img/[name].[hash:7].[ext]')\n              }\n            },\n            {\n              test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n              loader: 'url-loader',\n              options: {\n                limit: 10000,\n                name: utils.assetsPath('media/[name].[hash:7].[ext]')\n              }\n            },\n            {\n              test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n              loader: 'url-loader',\n              options: {\n                limit: 10000,\n                name: utils.assetsPath('fonts/[name].[hash:7].[ext]')\n              }\n            }\n          ]\n        }\n            \n   必选属性:\n   \n   test: 匹配要处理的文件扩展名(正则表达式)\n   \n   loader而: 加载器\n   \n   可选属性:\n   \n   include: 手动添加必须处理的文件(文件夹)\n   exclude: 手动屏蔽不需要处理的文件(文件夹)\n      \n   query: 提供额外的处置选项,也可以直接写在loader里(webpack2应该是改成options,如上面的配置)\n   \n   \n        {test:/\\.png|jpe?g|ico$/,\n         loader:'url-loader',\n         exclude:'/node-modles/',(举例而已,实际没有)\n         query:{\n            limited:10000,\n            name: '[name].[ext]?[hash]'\n         }\n        }\n        \n        \n## bable \n将ES6转化为ES5的包,会有好几个包,核心功能在bable-core这个包中\n用的最多的是解析ES6的babel-prsent-es2015和解析jsx的bable-present-react\n配置如下:\n  \n  \n      loaders:[{\n        test:/\\.js$/,\n        exclude:'/node_modules',\n        laoder:'babel',\n        query:{\n            presets:['es2015','react']\n        }\n      }]\n      \nbable还有非常的配置选项,实际一般把配置选项放到'bablerc'这个单独的文件中,webpack会自动调用.","slug":"webpack总结-一","published":1,"updated":"2018-09-14T16:38:30.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm28whmh000g7rs6co63hq74","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>作为一个前端开发者,现在已经不可避免的要和webpack打交道了,尤其使用vuejs以后,项目上不可避免要使用集成webpack的vue-cli.</p>\n<p>vue-cli基本上已经配置好了相关的webpack配置,基本上就可以开发了,不用开发人员再配置webpack,省时省力.</p>\n<p>但是webpack还是要弄清除基本的配置,尤其在面试的时候不可避免被问到,我在网上看到好多讲解的文章,受益匪浅,但是总是看时明白,过两天就忘记了,望而复始,所以想总结一下,以便能有个地方可以随时查阅,下面会引用别人的文章,以及自己的理解,肯定会有错误之处,请多对比.</p>\n<h1 id=\"webpack特点\"><a href=\"#webpack特点\" class=\"headerlink\" title=\"webpack特点\"></a>webpack特点</h1><p>是一个模块打包工具,不同于gulp,gulp只是一个构建工具,只执行相应的任务,比如说压缩/合并/检查/自动刷新等等,替代了人工操作,提高了开发人员的工作效率而已,不会对项目结构有所影响.</p>\n<p>webpack会把js/css/image/html等文件都视作模块,根据模块依赖关系进行静态分析,然后将这些模块按照指定的规则生成对应的静态资源.不仅仅可以执行压缩/合并等任务,还会深度参与项目结构.而且可以根据需求生成多个打包js,可以异步加载,实现按需加载.</p>\n<p>两个特点:</p>\n<ol>\n<li><p>一切皆模块</p>\n</li>\n<li><p>按需加载</p>\n</li>\n</ol>\n<h1 id=\"webpack基本配置\"><a href=\"#webpack基本配置\" class=\"headerlink\" title=\"webpack基本配置\"></a>webpack基本配置</h1><p>可以子命令行执行  webpack ………来打包</p>\n<p>一般专门配置webpack.config.js来方便的只在命令行执行webpack来打包.</p>\n<p>实际开发中一般又分成webpack.dev.config.js和webpack.build.config.js,还可能有webpack.test.config.js.具体可以参考vue-cli,后面在具体讲解.</p>\n<pre><code>const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //installed via npm\nconst webpack = require(&apos;webpack&apos;); //to access built-in plugins\nconst path = require(&apos;path&apos;);\n\nconst config = {\n  entry: &apos;./path/to/my/entry/file.js&apos;,\n  output: {\n    path: path.resolve(__dirname, &apos;dist&apos;),\n    filename: &apos;my-first-webpack.bundle.js&apos;\n  },\n  module: {\n    rules: [\n      {test: /\\.(js|jsx)$/, loader: &apos;babel-loader&apos;}\n    ]\n  },\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin(),\n    new HtmlWebpackPlugin({template: &apos;./src/index.html&apos;})\n  ]\n};\n\nmodule.exports = config;\n</code></pre><p>这是一个简单的示例,还有其他配置选项,下面一个一个来介绍.(因为webpack2配置方面有点改变比如,loader-&gt;rules等等,可能下面的会有所冲突)<br><a id=\"more\"></a></p>\n<h2 id=\"生成source-Maps-调试用\"><a href=\"#生成source-Maps-调试用\" class=\"headerlink\" title=\"生成source Maps(调试用)\"></a>生成source Maps(调试用)</h2><p>需要在配置中设置<br>devtool:’source-map’  (总共有七个选项,不同选项,打包速度也快,但也越不利于调试,调试也是各坑,有的选项打不上断点或者断点在下一行)</p>\n<h2 id=\"构建本地服务器\"><a href=\"#构建本地服务器\" class=\"headerlink\" title=\"构建本地服务器\"></a>构建本地服务器</h2><p>只从有了nodejs以后,前端就可以用node在本地起服务,而不用在配置java服务.<br>而且webpack也是基于nodejs的.</p>\n<p>1.npm 安装webpack-dev-server,这是一个基于express的webpack服务.</p>\n<p>2.在配置中</p>\n<pre><code>devServer:{\n    contentBase:&apos;./dist&apos;,\n    colors:true,\n    historyApiFallback:true,\n    inline:true\n}\n</code></pre><h2 id=\"loaders\"><a href=\"#loaders\" class=\"headerlink\" title=\"loaders\"></a>loaders</h2><p>   通过不同的loader,对各种文件进行处理</p>\n<ol>\n<li>安装</li>\n<li>在配置的modules属性下进行配置</li>\n</ol>\n<pre><code>module: {\n    rules: [\n      {\n        test: /\\.(js|vue)$/,\n        loader: &apos;eslint-loader&apos;,\n        enforce: &apos;pre&apos;,\n        include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)],\n        options: {\n          formatter: require(&apos;eslint-friendly-formatter&apos;)\n        }\n      },\n      {\n        test: /\\.vue$/,\n        loader: &apos;vue-loader&apos;,\n        options: vueLoaderConfig\n      },\n      {\n        test: /\\.js$/,\n        loader: &apos;babel-loader&apos;,\n        include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)]\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: &apos;url-loader&apos;,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;)\n        }\n      },\n      {\n        test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n        loader: &apos;url-loader&apos;,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;media/[name].[hash:7].[ext]&apos;)\n        }\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: &apos;url-loader&apos;,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;)\n        }\n      }\n    ]\n  }\n</code></pre><p>   必选属性:</p>\n<p>   test: 匹配要处理的文件扩展名(正则表达式)</p>\n<p>   loader而: 加载器</p>\n<p>   可选属性:</p>\n<p>   include: 手动添加必须处理的文件(文件夹)<br>   exclude: 手动屏蔽不需要处理的文件(文件夹)</p>\n<p>   query: 提供额外的处置选项,也可以直接写在loader里(webpack2应该是改成options,如上面的配置)</p>\n<pre><code>{test:/\\.png|jpe?g|ico$/,\n loader:&apos;url-loader&apos;,\n exclude:&apos;/node-modles/&apos;,(举例而已,实际没有)\n query:{\n    limited:10000,\n    name: &apos;[name].[ext]?[hash]&apos;\n }\n}\n</code></pre><h2 id=\"bable\"><a href=\"#bable\" class=\"headerlink\" title=\"bable\"></a>bable</h2><p>将ES6转化为ES5的包,会有好几个包,核心功能在bable-core这个包中<br>用的最多的是解析ES6的babel-prsent-es2015和解析jsx的bable-present-react<br>配置如下:</p>\n<pre><code>loaders:[{\n  test:/\\.js$/,\n  exclude:&apos;/node_modules&apos;,\n  laoder:&apos;babel&apos;,\n  query:{\n      presets:[&apos;es2015&apos;,&apos;react&apos;]\n  }\n}]\n</code></pre><p>bable还有非常的配置选项,实际一般把配置选项放到’bablerc’这个单独的文件中,webpack会自动调用.</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>作为一个前端开发者,现在已经不可避免的要和webpack打交道了,尤其使用vuejs以后,项目上不可避免要使用集成webpack的vue-cli.</p>\n<p>vue-cli基本上已经配置好了相关的webpack配置,基本上就可以开发了,不用开发人员再配置webpack,省时省力.</p>\n<p>但是webpack还是要弄清除基本的配置,尤其在面试的时候不可避免被问到,我在网上看到好多讲解的文章,受益匪浅,但是总是看时明白,过两天就忘记了,望而复始,所以想总结一下,以便能有个地方可以随时查阅,下面会引用别人的文章,以及自己的理解,肯定会有错误之处,请多对比.</p>\n<h1 id=\"webpack特点\"><a href=\"#webpack特点\" class=\"headerlink\" title=\"webpack特点\"></a>webpack特点</h1><p>是一个模块打包工具,不同于gulp,gulp只是一个构建工具,只执行相应的任务,比如说压缩/合并/检查/自动刷新等等,替代了人工操作,提高了开发人员的工作效率而已,不会对项目结构有所影响.</p>\n<p>webpack会把js/css/image/html等文件都视作模块,根据模块依赖关系进行静态分析,然后将这些模块按照指定的规则生成对应的静态资源.不仅仅可以执行压缩/合并等任务,还会深度参与项目结构.而且可以根据需求生成多个打包js,可以异步加载,实现按需加载.</p>\n<p>两个特点:</p>\n<ol>\n<li><p>一切皆模块</p>\n</li>\n<li><p>按需加载</p>\n</li>\n</ol>\n<h1 id=\"webpack基本配置\"><a href=\"#webpack基本配置\" class=\"headerlink\" title=\"webpack基本配置\"></a>webpack基本配置</h1><p>可以子命令行执行  webpack ………来打包</p>\n<p>一般专门配置webpack.config.js来方便的只在命令行执行webpack来打包.</p>\n<p>实际开发中一般又分成webpack.dev.config.js和webpack.build.config.js,还可能有webpack.test.config.js.具体可以参考vue-cli,后面在具体讲解.</p>\n<pre><code>const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //installed via npm\nconst webpack = require(&apos;webpack&apos;); //to access built-in plugins\nconst path = require(&apos;path&apos;);\n\nconst config = {\n  entry: &apos;./path/to/my/entry/file.js&apos;,\n  output: {\n    path: path.resolve(__dirname, &apos;dist&apos;),\n    filename: &apos;my-first-webpack.bundle.js&apos;\n  },\n  module: {\n    rules: [\n      {test: /\\.(js|jsx)$/, loader: &apos;babel-loader&apos;}\n    ]\n  },\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin(),\n    new HtmlWebpackPlugin({template: &apos;./src/index.html&apos;})\n  ]\n};\n\nmodule.exports = config;\n</code></pre><p>这是一个简单的示例,还有其他配置选项,下面一个一个来介绍.(因为webpack2配置方面有点改变比如,loader-&gt;rules等等,可能下面的会有所冲突)<br>","more":"</p>\n<h2 id=\"生成source-Maps-调试用\"><a href=\"#生成source-Maps-调试用\" class=\"headerlink\" title=\"生成source Maps(调试用)\"></a>生成source Maps(调试用)</h2><p>需要在配置中设置<br>devtool:’source-map’  (总共有七个选项,不同选项,打包速度也快,但也越不利于调试,调试也是各坑,有的选项打不上断点或者断点在下一行)</p>\n<h2 id=\"构建本地服务器\"><a href=\"#构建本地服务器\" class=\"headerlink\" title=\"构建本地服务器\"></a>构建本地服务器</h2><p>只从有了nodejs以后,前端就可以用node在本地起服务,而不用在配置java服务.<br>而且webpack也是基于nodejs的.</p>\n<p>1.npm 安装webpack-dev-server,这是一个基于express的webpack服务.</p>\n<p>2.在配置中</p>\n<pre><code>devServer:{\n    contentBase:&apos;./dist&apos;,\n    colors:true,\n    historyApiFallback:true,\n    inline:true\n}\n</code></pre><h2 id=\"loaders\"><a href=\"#loaders\" class=\"headerlink\" title=\"loaders\"></a>loaders</h2><p>   通过不同的loader,对各种文件进行处理</p>\n<ol>\n<li>安装</li>\n<li>在配置的modules属性下进行配置</li>\n</ol>\n<pre><code>module: {\n    rules: [\n      {\n        test: /\\.(js|vue)$/,\n        loader: &apos;eslint-loader&apos;,\n        enforce: &apos;pre&apos;,\n        include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)],\n        options: {\n          formatter: require(&apos;eslint-friendly-formatter&apos;)\n        }\n      },\n      {\n        test: /\\.vue$/,\n        loader: &apos;vue-loader&apos;,\n        options: vueLoaderConfig\n      },\n      {\n        test: /\\.js$/,\n        loader: &apos;babel-loader&apos;,\n        include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)]\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: &apos;url-loader&apos;,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;)\n        }\n      },\n      {\n        test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n        loader: &apos;url-loader&apos;,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;media/[name].[hash:7].[ext]&apos;)\n        }\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: &apos;url-loader&apos;,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;)\n        }\n      }\n    ]\n  }\n</code></pre><p>   必选属性:</p>\n<p>   test: 匹配要处理的文件扩展名(正则表达式)</p>\n<p>   loader而: 加载器</p>\n<p>   可选属性:</p>\n<p>   include: 手动添加必须处理的文件(文件夹)<br>   exclude: 手动屏蔽不需要处理的文件(文件夹)</p>\n<p>   query: 提供额外的处置选项,也可以直接写在loader里(webpack2应该是改成options,如上面的配置)</p>\n<pre><code>{test:/\\.png|jpe?g|ico$/,\n loader:&apos;url-loader&apos;,\n exclude:&apos;/node-modles/&apos;,(举例而已,实际没有)\n query:{\n    limited:10000,\n    name: &apos;[name].[ext]?[hash]&apos;\n }\n}\n</code></pre><h2 id=\"bable\"><a href=\"#bable\" class=\"headerlink\" title=\"bable\"></a>bable</h2><p>将ES6转化为ES5的包,会有好几个包,核心功能在bable-core这个包中<br>用的最多的是解析ES6的babel-prsent-es2015和解析jsx的bable-present-react<br>配置如下:</p>\n<pre><code>loaders:[{\n  test:/\\.js$/,\n  exclude:&apos;/node_modules&apos;,\n  laoder:&apos;babel&apos;,\n  query:{\n      presets:[&apos;es2015&apos;,&apos;react&apos;]\n  }\n}]\n</code></pre><p>bable还有非常的配置选项,实际一般把配置选项放到’bablerc’这个单独的文件中,webpack会自动调用.</p>"},{"title":"webpack总结三","date":"2017-10-07T13:05:18.000Z","_content":"\n## 插件\nwebpack有很多内置插件,也有第三方插件,用来拓展webpack相关功能\n如果是第三方插件,需要先安装\n\n### HtmlWebpackPlugin\n自动生成html插件,自动在dist目录下自动生成一个index.html\n<!-- more -->\n    \n     //webpack.config.js\n      var HtmlWebpackPlugin = require('html-webpack-plugin');\n      module.exports={\n        entry:'./index.js',\n        output:{\n          path:__dirname+'/dist',\n          filename:'bundle.js'\n        }\n        plugins:[\n          new HtmlWebpackPlugin()\n        ]\n      }\n      \n更多的配置\n      \n       plugins: [\n          new HtmlWebpackPlugin({\n            title: 'My App',\n            filename: 'admin.html',\n            template:'header.html',\n            inject: 'body',\n            favicon:'./images/favico.ico',\n            minify:true,\n            hash:true,\n            cache:false,\n            showErrors:false,\n            \"chunks\": {\n            \"head\": {\n              \"entry\": \"assets/head_bundle.js\",\n              \"css\": [ \"main.css\" ]\n            },\n            xhtml:false\n          })\n        ]\n\n### extract-text-webpack-plugin\n提取样式插件\n\n        var ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\n        new ExtractTextPlugin(\"[name].[hash].css\")\n        \n                \n## 优化插件\n需要在生产打包时进行额外的处理,比如压缩js代码.\n就要用到内置插件UgilifyJsPugin\n    \n        plugins:[\n            new webpack.optimize.UglifJsPlugin()\n        ]\n        \n在生产打包会有更多处理,在vue-cli中有以下配置\n        \n        new webpack.optimize.CommonsChunkPlugin({\n              name: 'vendor',\n              minChunks: function (module, count) {\n                // any required modules inside node_modules are extracted to vendor\n                return (\n                  module.resource &&\n                  /\\.js$/.test(module.resource) &&\n                  module.resource.indexOf(\n                    path.join(__dirname, '../node_modules')\n                  ) === 0\n                )\n              }\n            }),\n            // extract webpack runtime and module manifest to its own file in order to\n            // prevent vendor hash from being updated whenever app bundle is updated\n            new webpack.optimize.CommonsChunkPlugin({\n              name: 'manifest',\n              chunks: ['vendor']\n            }),\n            \n            \n总之,webpack配置还挺复杂,值得弄明白,听说以前还有专门的webpack岗位,下面还会就vue-cli这种专业的配置总结一下.\n           ","source":"_posts/webpack总结三.md","raw":"---\ntitle: webpack总结三\ndate: 2017-10-07 21:05:18\ntags: [webpack] \ncategories: [front]\n---\n\n## 插件\nwebpack有很多内置插件,也有第三方插件,用来拓展webpack相关功能\n如果是第三方插件,需要先安装\n\n### HtmlWebpackPlugin\n自动生成html插件,自动在dist目录下自动生成一个index.html\n<!-- more -->\n    \n     //webpack.config.js\n      var HtmlWebpackPlugin = require('html-webpack-plugin');\n      module.exports={\n        entry:'./index.js',\n        output:{\n          path:__dirname+'/dist',\n          filename:'bundle.js'\n        }\n        plugins:[\n          new HtmlWebpackPlugin()\n        ]\n      }\n      \n更多的配置\n      \n       plugins: [\n          new HtmlWebpackPlugin({\n            title: 'My App',\n            filename: 'admin.html',\n            template:'header.html',\n            inject: 'body',\n            favicon:'./images/favico.ico',\n            minify:true,\n            hash:true,\n            cache:false,\n            showErrors:false,\n            \"chunks\": {\n            \"head\": {\n              \"entry\": \"assets/head_bundle.js\",\n              \"css\": [ \"main.css\" ]\n            },\n            xhtml:false\n          })\n        ]\n\n### extract-text-webpack-plugin\n提取样式插件\n\n        var ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\n        new ExtractTextPlugin(\"[name].[hash].css\")\n        \n                \n## 优化插件\n需要在生产打包时进行额外的处理,比如压缩js代码.\n就要用到内置插件UgilifyJsPugin\n    \n        plugins:[\n            new webpack.optimize.UglifJsPlugin()\n        ]\n        \n在生产打包会有更多处理,在vue-cli中有以下配置\n        \n        new webpack.optimize.CommonsChunkPlugin({\n              name: 'vendor',\n              minChunks: function (module, count) {\n                // any required modules inside node_modules are extracted to vendor\n                return (\n                  module.resource &&\n                  /\\.js$/.test(module.resource) &&\n                  module.resource.indexOf(\n                    path.join(__dirname, '../node_modules')\n                  ) === 0\n                )\n              }\n            }),\n            // extract webpack runtime and module manifest to its own file in order to\n            // prevent vendor hash from being updated whenever app bundle is updated\n            new webpack.optimize.CommonsChunkPlugin({\n              name: 'manifest',\n              chunks: ['vendor']\n            }),\n            \n            \n总之,webpack配置还挺复杂,值得弄明白,听说以前还有专门的webpack岗位,下面还会就vue-cli这种专业的配置总结一下.\n           ","slug":"webpack总结三","published":1,"updated":"2018-09-14T16:38:30.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm28whmk000j7rs62oelxqxc","content":"<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><p>webpack有很多内置插件,也有第三方插件,用来拓展webpack相关功能<br>如果是第三方插件,需要先安装</p>\n<h3 id=\"HtmlWebpackPlugin\"><a href=\"#HtmlWebpackPlugin\" class=\"headerlink\" title=\"HtmlWebpackPlugin\"></a>HtmlWebpackPlugin</h3><p>自动生成html插件,自动在dist目录下自动生成一个index.html<br><a id=\"more\"></a></p>\n<pre><code>//webpack.config.js\n var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);\n module.exports={\n   entry:&apos;./index.js&apos;,\n   output:{\n     path:__dirname+&apos;/dist&apos;,\n     filename:&apos;bundle.js&apos;\n   }\n   plugins:[\n     new HtmlWebpackPlugin()\n   ]\n }\n</code></pre><p>更多的配置</p>\n<pre><code>plugins: [\n   new HtmlWebpackPlugin({\n     title: &apos;My App&apos;,\n     filename: &apos;admin.html&apos;,\n     template:&apos;header.html&apos;,\n     inject: &apos;body&apos;,\n     favicon:&apos;./images/favico.ico&apos;,\n     minify:true,\n     hash:true,\n     cache:false,\n     showErrors:false,\n     &quot;chunks&quot;: {\n     &quot;head&quot;: {\n       &quot;entry&quot;: &quot;assets/head_bundle.js&quot;,\n       &quot;css&quot;: [ &quot;main.css&quot; ]\n     },\n     xhtml:false\n   })\n ]\n</code></pre><h3 id=\"extract-text-webpack-plugin\"><a href=\"#extract-text-webpack-plugin\" class=\"headerlink\" title=\"extract-text-webpack-plugin\"></a>extract-text-webpack-plugin</h3><p>提取样式插件</p>\n<pre><code>var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);\nnew ExtractTextPlugin(&quot;[name].[hash].css&quot;)\n</code></pre><h2 id=\"优化插件\"><a href=\"#优化插件\" class=\"headerlink\" title=\"优化插件\"></a>优化插件</h2><p>需要在生产打包时进行额外的处理,比如压缩js代码.<br>就要用到内置插件UgilifyJsPugin</p>\n<pre><code>plugins:[\n    new webpack.optimize.UglifJsPlugin()\n]\n</code></pre><p>在生产打包会有更多处理,在vue-cli中有以下配置</p>\n<pre><code>new webpack.optimize.CommonsChunkPlugin({\n      name: &apos;vendor&apos;,\n      minChunks: function (module, count) {\n        // any required modules inside node_modules are extracted to vendor\n        return (\n          module.resource &amp;&amp;\n          /\\.js$/.test(module.resource) &amp;&amp;\n          module.resource.indexOf(\n            path.join(__dirname, &apos;../node_modules&apos;)\n          ) === 0\n        )\n      }\n    }),\n    // extract webpack runtime and module manifest to its own file in order to\n    // prevent vendor hash from being updated whenever app bundle is updated\n    new webpack.optimize.CommonsChunkPlugin({\n      name: &apos;manifest&apos;,\n      chunks: [&apos;vendor&apos;]\n    }),\n</code></pre><p>总之,webpack配置还挺复杂,值得弄明白,听说以前还有专门的webpack岗位,下面还会就vue-cli这种专业的配置总结一下.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><p>webpack有很多内置插件,也有第三方插件,用来拓展webpack相关功能<br>如果是第三方插件,需要先安装</p>\n<h3 id=\"HtmlWebpackPlugin\"><a href=\"#HtmlWebpackPlugin\" class=\"headerlink\" title=\"HtmlWebpackPlugin\"></a>HtmlWebpackPlugin</h3><p>自动生成html插件,自动在dist目录下自动生成一个index.html<br>","more":"</p>\n<pre><code>//webpack.config.js\n var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);\n module.exports={\n   entry:&apos;./index.js&apos;,\n   output:{\n     path:__dirname+&apos;/dist&apos;,\n     filename:&apos;bundle.js&apos;\n   }\n   plugins:[\n     new HtmlWebpackPlugin()\n   ]\n }\n</code></pre><p>更多的配置</p>\n<pre><code>plugins: [\n   new HtmlWebpackPlugin({\n     title: &apos;My App&apos;,\n     filename: &apos;admin.html&apos;,\n     template:&apos;header.html&apos;,\n     inject: &apos;body&apos;,\n     favicon:&apos;./images/favico.ico&apos;,\n     minify:true,\n     hash:true,\n     cache:false,\n     showErrors:false,\n     &quot;chunks&quot;: {\n     &quot;head&quot;: {\n       &quot;entry&quot;: &quot;assets/head_bundle.js&quot;,\n       &quot;css&quot;: [ &quot;main.css&quot; ]\n     },\n     xhtml:false\n   })\n ]\n</code></pre><h3 id=\"extract-text-webpack-plugin\"><a href=\"#extract-text-webpack-plugin\" class=\"headerlink\" title=\"extract-text-webpack-plugin\"></a>extract-text-webpack-plugin</h3><p>提取样式插件</p>\n<pre><code>var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);\nnew ExtractTextPlugin(&quot;[name].[hash].css&quot;)\n</code></pre><h2 id=\"优化插件\"><a href=\"#优化插件\" class=\"headerlink\" title=\"优化插件\"></a>优化插件</h2><p>需要在生产打包时进行额外的处理,比如压缩js代码.<br>就要用到内置插件UgilifyJsPugin</p>\n<pre><code>plugins:[\n    new webpack.optimize.UglifJsPlugin()\n]\n</code></pre><p>在生产打包会有更多处理,在vue-cli中有以下配置</p>\n<pre><code>new webpack.optimize.CommonsChunkPlugin({\n      name: &apos;vendor&apos;,\n      minChunks: function (module, count) {\n        // any required modules inside node_modules are extracted to vendor\n        return (\n          module.resource &amp;&amp;\n          /\\.js$/.test(module.resource) &amp;&amp;\n          module.resource.indexOf(\n            path.join(__dirname, &apos;../node_modules&apos;)\n          ) === 0\n        )\n      }\n    }),\n    // extract webpack runtime and module manifest to its own file in order to\n    // prevent vendor hash from being updated whenever app bundle is updated\n    new webpack.optimize.CommonsChunkPlugin({\n      name: &apos;manifest&apos;,\n      chunks: [&apos;vendor&apos;]\n    }),\n</code></pre><p>总之,webpack配置还挺复杂,值得弄明白,听说以前还有专门的webpack岗位,下面还会就vue-cli这种专业的配置总结一下.</p>"},{"title":"使用代理解决跨域限制","date":"2017-10-06T13:00:53.000Z","_content":"# 问题\n\n1 . 在跨域请求(经常是在用到别人的接口时)会遇到一些限制,对方会检查http请求携带的来源,比如检查host,referer等.\n\n## 代理\n\n1 .\n    我们可以在本地起一个node服务,比如vue开发中的dev-server,使用其发http请求,通过修该请求信息,能够被对方接口通过返回数据,又因为同源策略是浏览器安全的范畴,所以在node上不用考虑跨域问题.\n2 .\n    项目中只需发一个ajax请求(因为向本地node服务发,故同源,不用考虑跨域).vue中使用axios作为ajax工具,其既可以在浏览器中使用,也可以在node中使用.\n\n        import axios from 'axios',\n        let url = '/api/getData',\n        let data = {....},\n        axios.get(url, {\n            params: data\n        }).then((res) => {\n          ...........................\n          })\n\n3 .\n    在本地node服务中对请求'/api/getData'做代理,发请求到实际的接口\n\n        var axios = require('axios')\n        var app = express()\n        var apiRoutes = express.Router()\n\n        apiRoutes.get('/getData', function (req, res) {\n            //实际接口\n          var url = 'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg'\n          //修改请求头信息\n          axios.get(url, {\n            headers: {\n              referer: 'https://c.y.qq.com/',\n              host: 'c.y.qq.com'\n            },\n            params: req.query\n          }).then((response) => {\n            res.json(response.data)\n          }).catch((e) => {\n            console.log(e)\n          })\n        })\n\n        app.use('/api', apiRoutes)\n\n\n\n","source":"_posts/使用代理解决跨域限制.md","raw":"---\ntitle: 使用代理解决跨域限制\ndate: 2017-10-06 21:00:53\ntags: [跨域, vue] \ncategories: [front]\n---\n# 问题\n\n1 . 在跨域请求(经常是在用到别人的接口时)会遇到一些限制,对方会检查http请求携带的来源,比如检查host,referer等.\n\n## 代理\n\n1 .\n    我们可以在本地起一个node服务,比如vue开发中的dev-server,使用其发http请求,通过修该请求信息,能够被对方接口通过返回数据,又因为同源策略是浏览器安全的范畴,所以在node上不用考虑跨域问题.\n2 .\n    项目中只需发一个ajax请求(因为向本地node服务发,故同源,不用考虑跨域).vue中使用axios作为ajax工具,其既可以在浏览器中使用,也可以在node中使用.\n\n        import axios from 'axios',\n        let url = '/api/getData',\n        let data = {....},\n        axios.get(url, {\n            params: data\n        }).then((res) => {\n          ...........................\n          })\n\n3 .\n    在本地node服务中对请求'/api/getData'做代理,发请求到实际的接口\n\n        var axios = require('axios')\n        var app = express()\n        var apiRoutes = express.Router()\n\n        apiRoutes.get('/getData', function (req, res) {\n            //实际接口\n          var url = 'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg'\n          //修改请求头信息\n          axios.get(url, {\n            headers: {\n              referer: 'https://c.y.qq.com/',\n              host: 'c.y.qq.com'\n            },\n            params: req.query\n          }).then((response) => {\n            res.json(response.data)\n          }).catch((e) => {\n            console.log(e)\n          })\n        })\n\n        app.use('/api', apiRoutes)\n\n\n\n","slug":"使用代理解决跨域限制","published":1,"updated":"2018-09-14T16:38:30.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm28whml000m7rs6vjq3pkjz","content":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>1 . 在跨域请求(经常是在用到别人的接口时)会遇到一些限制,对方会检查http请求携带的来源,比如检查host,referer等.</p>\n<h2 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h2><p>1 .<br>    我们可以在本地起一个node服务,比如vue开发中的dev-server,使用其发http请求,通过修该请求信息,能够被对方接口通过返回数据,又因为同源策略是浏览器安全的范畴,所以在node上不用考虑跨域问题.<br>2 .<br>    项目中只需发一个ajax请求(因为向本地node服务发,故同源,不用考虑跨域).vue中使用axios作为ajax工具,其既可以在浏览器中使用,也可以在node中使用.</p>\n<pre><code>import axios from &apos;axios&apos;,\nlet url = &apos;/api/getData&apos;,\nlet data = {....},\naxios.get(url, {\n    params: data\n}).then((res) =&gt; {\n  ...........................\n  })\n</code></pre><p>3 .<br>    在本地node服务中对请求’/api/getData’做代理,发请求到实际的接口</p>\n<pre><code>var axios = require(&apos;axios&apos;)\nvar app = express()\nvar apiRoutes = express.Router()\n\napiRoutes.get(&apos;/getData&apos;, function (req, res) {\n    //实际接口\n  var url = &apos;https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg&apos;\n  //修改请求头信息\n  axios.get(url, {\n    headers: {\n      referer: &apos;https://c.y.qq.com/&apos;,\n      host: &apos;c.y.qq.com&apos;\n    },\n    params: req.query\n  }).then((response) =&gt; {\n    res.json(response.data)\n  }).catch((e) =&gt; {\n    console.log(e)\n  })\n})\n\napp.use(&apos;/api&apos;, apiRoutes)\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>1 . 在跨域请求(经常是在用到别人的接口时)会遇到一些限制,对方会检查http请求携带的来源,比如检查host,referer等.</p>\n<h2 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h2><p>1 .<br>    我们可以在本地起一个node服务,比如vue开发中的dev-server,使用其发http请求,通过修该请求信息,能够被对方接口通过返回数据,又因为同源策略是浏览器安全的范畴,所以在node上不用考虑跨域问题.<br>2 .<br>    项目中只需发一个ajax请求(因为向本地node服务发,故同源,不用考虑跨域).vue中使用axios作为ajax工具,其既可以在浏览器中使用,也可以在node中使用.</p>\n<pre><code>import axios from &apos;axios&apos;,\nlet url = &apos;/api/getData&apos;,\nlet data = {....},\naxios.get(url, {\n    params: data\n}).then((res) =&gt; {\n  ...........................\n  })\n</code></pre><p>3 .<br>    在本地node服务中对请求’/api/getData’做代理,发请求到实际的接口</p>\n<pre><code>var axios = require(&apos;axios&apos;)\nvar app = express()\nvar apiRoutes = express.Router()\n\napiRoutes.get(&apos;/getData&apos;, function (req, res) {\n    //实际接口\n  var url = &apos;https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg&apos;\n  //修改请求头信息\n  axios.get(url, {\n    headers: {\n      referer: &apos;https://c.y.qq.com/&apos;,\n      host: &apos;c.y.qq.com&apos;\n    },\n    params: req.query\n  }).then((response) =&gt; {\n    res.json(response.data)\n  }).catch((e) =&gt; {\n    console.log(e)\n  })\n})\n\napp.use(&apos;/api&apos;, apiRoutes)\n</code></pre>"},{"title":"webpack总结二","date":"2017-10-07T08:41:33.000Z","_content":"### css\nwebpack提供了两个工具处理样式表 --> css-loader 和 style-loader\ncss-loader 可以使用类似@import或url(...)的方法实现require的功能\nstyle-loader将所有计算后的样式加入到页面中\n两者缺一不可(多个加载器中间用!分割,从右向左执行,也可写成数组形式)\n    \n    {test:/\\.css$/,\n    loader:'style!css'  \n    //也可以写成\n    loader:['style','css']\n    }\n<!-- more -->\n\n### css预处理\n比如 less-loader/sass-loader/sylus-loader\n以less为例\n\n先npm i less-loader  --dev\n    \n    \n    {\n            test: /\\.(less|css)$/,\n            use:[ 'style-loader','css-loader','less-loader'],\n    },\n    \n    \n### postcss  \n有好几个功能,这里只介绍为css代码添加前缀来适应不同的浏览器\n 先安装postcss-loader 和 依赖的插件autoprefixer\n 在配置中(webpack2中配置方式好像变化了,注意)\n \n    module: {\n            rules: [\n              {test: /\\.css$/, loader: 'style!css!postcss'}\n            ]\n          },\n    postcss: [require('autoprefixer')]  //声明依赖的插件   \n\n    \n### entry(入口)\n可以是字符串,数组,对象\n1. 只有一个入口\n2. 添加彼此互不依赖文件用数组,如['./xx/a.js', './xx/b.js'],\n最后打包时会在bundle.js后面添加b.js\n3. 如果是多页面应用(非spa),则为每个页面生成一个bundle文件,\n\n\n    entry:{\n            'indexEntry' : './src/index,js',\n            'pageAEntry' : './src/pageA.js'\n           },\n    output:{\n            path:'./dist',\n            filename:'[name].js' //name取自entry的属性键名\n          }  \n           \n\n            \n### output(输出)            \n两个选项\n\n    \n    output: {\n            path: './dist',   //webpack打包后文件存放位置\n            publicPath: 'http://cdn...'  //生产环境下  静态资源访问地址,比如要把打包后的文件放到cnd上,就可以配置这个选项\n            }","source":"_posts/webpack总结二.md","raw":"---\ntitle: webpack总结二\ndate: 2017-10-07 16:41:33\ntags: [webpack] \ncategories: [front]\n---\n### css\nwebpack提供了两个工具处理样式表 --> css-loader 和 style-loader\ncss-loader 可以使用类似@import或url(...)的方法实现require的功能\nstyle-loader将所有计算后的样式加入到页面中\n两者缺一不可(多个加载器中间用!分割,从右向左执行,也可写成数组形式)\n    \n    {test:/\\.css$/,\n    loader:'style!css'  \n    //也可以写成\n    loader:['style','css']\n    }\n<!-- more -->\n\n### css预处理\n比如 less-loader/sass-loader/sylus-loader\n以less为例\n\n先npm i less-loader  --dev\n    \n    \n    {\n            test: /\\.(less|css)$/,\n            use:[ 'style-loader','css-loader','less-loader'],\n    },\n    \n    \n### postcss  \n有好几个功能,这里只介绍为css代码添加前缀来适应不同的浏览器\n 先安装postcss-loader 和 依赖的插件autoprefixer\n 在配置中(webpack2中配置方式好像变化了,注意)\n \n    module: {\n            rules: [\n              {test: /\\.css$/, loader: 'style!css!postcss'}\n            ]\n          },\n    postcss: [require('autoprefixer')]  //声明依赖的插件   \n\n    \n### entry(入口)\n可以是字符串,数组,对象\n1. 只有一个入口\n2. 添加彼此互不依赖文件用数组,如['./xx/a.js', './xx/b.js'],\n最后打包时会在bundle.js后面添加b.js\n3. 如果是多页面应用(非spa),则为每个页面生成一个bundle文件,\n\n\n    entry:{\n            'indexEntry' : './src/index,js',\n            'pageAEntry' : './src/pageA.js'\n           },\n    output:{\n            path:'./dist',\n            filename:'[name].js' //name取自entry的属性键名\n          }  \n           \n\n            \n### output(输出)            \n两个选项\n\n    \n    output: {\n            path: './dist',   //webpack打包后文件存放位置\n            publicPath: 'http://cdn...'  //生产环境下  静态资源访问地址,比如要把打包后的文件放到cnd上,就可以配置这个选项\n            }","slug":"webpack总结二","published":1,"updated":"2018-09-14T16:38:30.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm28whmm000q7rs6faa9zhbg","content":"<h3 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css\"></a>css</h3><p>webpack提供了两个工具处理样式表 –&gt; css-loader 和 style-loader<br>css-loader 可以使用类似@import或url(…)的方法实现require的功能<br>style-loader将所有计算后的样式加入到页面中<br>两者缺一不可(多个加载器中间用!分割,从右向左执行,也可写成数组形式)</p>\n<pre><code>{test:/\\.css$/,\nloader:&apos;style!css&apos;  \n//也可以写成\nloader:[&apos;style&apos;,&apos;css&apos;]\n}\n</code></pre><a id=\"more\"></a>\n<h3 id=\"css预处理\"><a href=\"#css预处理\" class=\"headerlink\" title=\"css预处理\"></a>css预处理</h3><p>比如 less-loader/sass-loader/sylus-loader<br>以less为例</p>\n<p>先npm i less-loader  –dev</p>\n<pre><code>{\n        test: /\\.(less|css)$/,\n        use:[ &apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;],\n},\n</code></pre><h3 id=\"postcss\"><a href=\"#postcss\" class=\"headerlink\" title=\"postcss\"></a>postcss</h3><p>有好几个功能,这里只介绍为css代码添加前缀来适应不同的浏览器<br> 先安装postcss-loader 和 依赖的插件autoprefixer<br> 在配置中(webpack2中配置方式好像变化了,注意)</p>\n<pre><code>module: {\n        rules: [\n          {test: /\\.css$/, loader: &apos;style!css!postcss&apos;}\n        ]\n      },\npostcss: [require(&apos;autoprefixer&apos;)]  //声明依赖的插件   \n</code></pre><h3 id=\"entry-入口\"><a href=\"#entry-入口\" class=\"headerlink\" title=\"entry(入口)\"></a>entry(入口)</h3><p>可以是字符串,数组,对象</p>\n<ol>\n<li>只有一个入口</li>\n<li>添加彼此互不依赖文件用数组,如[‘./xx/a.js’, ‘./xx/b.js’],<br>最后打包时会在bundle.js后面添加b.js</li>\n<li>如果是多页面应用(非spa),则为每个页面生成一个bundle文件,</li>\n</ol>\n<pre><code>entry:{\n        &apos;indexEntry&apos; : &apos;./src/index,js&apos;,\n        &apos;pageAEntry&apos; : &apos;./src/pageA.js&apos;\n       },\noutput:{\n        path:&apos;./dist&apos;,\n        filename:&apos;[name].js&apos; //name取自entry的属性键名\n      }  \n</code></pre><h3 id=\"output-输出\"><a href=\"#output-输出\" class=\"headerlink\" title=\"output(输出)\"></a>output(输出)</h3><p>两个选项</p>\n<pre><code>output: {\n        path: &apos;./dist&apos;,   //webpack打包后文件存放位置\n        publicPath: &apos;http://cdn...&apos;  //生产环境下  静态资源访问地址,比如要把打包后的文件放到cnd上,就可以配置这个选项\n        }\n</code></pre>","site":{"data":{}},"excerpt":"<h3 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css\"></a>css</h3><p>webpack提供了两个工具处理样式表 –&gt; css-loader 和 style-loader<br>css-loader 可以使用类似@import或url(…)的方法实现require的功能<br>style-loader将所有计算后的样式加入到页面中<br>两者缺一不可(多个加载器中间用!分割,从右向左执行,也可写成数组形式)</p>\n<pre><code>{test:/\\.css$/,\nloader:&apos;style!css&apos;  \n//也可以写成\nloader:[&apos;style&apos;,&apos;css&apos;]\n}\n</code></pre>","more":"<h3 id=\"css预处理\"><a href=\"#css预处理\" class=\"headerlink\" title=\"css预处理\"></a>css预处理</h3><p>比如 less-loader/sass-loader/sylus-loader<br>以less为例</p>\n<p>先npm i less-loader  –dev</p>\n<pre><code>{\n        test: /\\.(less|css)$/,\n        use:[ &apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;],\n},\n</code></pre><h3 id=\"postcss\"><a href=\"#postcss\" class=\"headerlink\" title=\"postcss\"></a>postcss</h3><p>有好几个功能,这里只介绍为css代码添加前缀来适应不同的浏览器<br> 先安装postcss-loader 和 依赖的插件autoprefixer<br> 在配置中(webpack2中配置方式好像变化了,注意)</p>\n<pre><code>module: {\n        rules: [\n          {test: /\\.css$/, loader: &apos;style!css!postcss&apos;}\n        ]\n      },\npostcss: [require(&apos;autoprefixer&apos;)]  //声明依赖的插件   \n</code></pre><h3 id=\"entry-入口\"><a href=\"#entry-入口\" class=\"headerlink\" title=\"entry(入口)\"></a>entry(入口)</h3><p>可以是字符串,数组,对象</p>\n<ol>\n<li>只有一个入口</li>\n<li>添加彼此互不依赖文件用数组,如[‘./xx/a.js’, ‘./xx/b.js’],<br>最后打包时会在bundle.js后面添加b.js</li>\n<li>如果是多页面应用(非spa),则为每个页面生成一个bundle文件,</li>\n</ol>\n<pre><code>entry:{\n        &apos;indexEntry&apos; : &apos;./src/index,js&apos;,\n        &apos;pageAEntry&apos; : &apos;./src/pageA.js&apos;\n       },\noutput:{\n        path:&apos;./dist&apos;,\n        filename:&apos;[name].js&apos; //name取自entry的属性键名\n      }  \n</code></pre><h3 id=\"output-输出\"><a href=\"#output-输出\" class=\"headerlink\" title=\"output(输出)\"></a>output(输出)</h3><p>两个选项</p>\n<pre><code>output: {\n        path: &apos;./dist&apos;,   //webpack打包后文件存放位置\n        publicPath: &apos;http://cdn...&apos;  //生产环境下  静态资源访问地址,比如要把打包后的文件放到cnd上,就可以配置这个选项\n        }\n</code></pre>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjm28whm900057rs65utz6r3f","category_id":"cjm28whm500027rs6p8787oej","_id":"cjm28whme000b7rs6vyap1zya"},{"post_id":"cjm28whly00007rs6b5dhg131","category_id":"cjm28whm500027rs6p8787oej","_id":"cjm28whmg000f7rs68ou9srdy"},{"post_id":"cjm28whma00067rs6rpkgrn75","category_id":"cjm28whm500027rs6p8787oej","_id":"cjm28whmj000h7rs60e3r4q5z"},{"post_id":"cjm28whmd00097rs60ceuz6rj","category_id":"cjm28whm500027rs6p8787oej","_id":"cjm28whmk000k7rs6l3eepypn"},{"post_id":"cjm28whm200017rs69ommqq69","category_id":"cjm28whm500027rs6p8787oej","_id":"cjm28whmm000n7rs68g4rimkd"},{"post_id":"cjm28whme000a7rs6g1klc05e","category_id":"cjm28whm500027rs6p8787oej","_id":"cjm28whmn000r7rs625q38cgj"},{"post_id":"cjm28whmf000e7rs6e0y4m1j8","category_id":"cjm28whm500027rs6p8787oej","_id":"cjm28whmo000t7rs6g6k1x29p"},{"post_id":"cjm28whm700047rs6ozvlcja1","category_id":"cjm28whm500027rs6p8787oej","_id":"cjm28whmp000u7rs6of5bze85"},{"post_id":"cjm28whmh000g7rs6co63hq74","category_id":"cjm28whm500027rs6p8787oej","_id":"cjm28whmp000w7rs6g2zozxp1"},{"post_id":"cjm28whmk000j7rs62oelxqxc","category_id":"cjm28whm500027rs6p8787oej","_id":"cjm28whmp000x7rs6lnrg5bat"},{"post_id":"cjm28whml000m7rs6vjq3pkjz","category_id":"cjm28whm500027rs6p8787oej","_id":"cjm28whmq000z7rs64ko83hlw"},{"post_id":"cjm28whmm000q7rs6faa9zhbg","category_id":"cjm28whm500027rs6p8787oej","_id":"cjm28whmq00107rs6mk00oaqm"}],"PostTag":[{"post_id":"cjm28whly00007rs6b5dhg131","tag_id":"cjm28whm700037rs6cla6vr3s","_id":"cjm28whml000l7rs6xoy3o03z"},{"post_id":"cjm28whly00007rs6b5dhg131","tag_id":"cjm28whmb00087rs6jh98xwhd","_id":"cjm28whmm000o7rs6w72uguxo"},{"post_id":"cjm28whly00007rs6b5dhg131","tag_id":"cjm28whmf000d7rs6yrmep1cf","_id":"cjm28whmo000s7rs6fy6fwu9d"},{"post_id":"cjm28whm200017rs69ommqq69","tag_id":"cjm28whmj000i7rs6ybf1kixl","_id":"cjm28whmq00127rs6dlwmtvyh"},{"post_id":"cjm28whm200017rs69ommqq69","tag_id":"cjm28whmm000p7rs6qpnv2grc","_id":"cjm28whmr00137rs6l9gjmb0z"},{"post_id":"cjm28whm200017rs69ommqq69","tag_id":"cjm28whmp000v7rs6ttks8bkm","_id":"cjm28whmr00157rs6s1pagswy"},{"post_id":"cjm28whm200017rs69ommqq69","tag_id":"cjm28whmq000y7rs6b0b1ttk5","_id":"cjm28whmr00167rs6mxt3ytny"},{"post_id":"cjm28whm700047rs6ozvlcja1","tag_id":"cjm28whmq00117rs6cl96cvjs","_id":"cjm28whmr00187rs693ns2hdd"},{"post_id":"cjm28whm900057rs65utz6r3f","tag_id":"cjm28whmr00147rs66rbvjmpi","_id":"cjm28whms001a7rs6vlheezuo"},{"post_id":"cjm28whm900057rs65utz6r3f","tag_id":"cjm28whmr00177rs62tfziapw","_id":"cjm28whms001b7rs6bhn2ovc1"},{"post_id":"cjm28whma00067rs6rpkgrn75","tag_id":"cjm28whmr00147rs66rbvjmpi","_id":"cjm28whmt001f7rs6cp2mqxgm"},{"post_id":"cjm28whma00067rs6rpkgrn75","tag_id":"cjm28whmr00177rs62tfziapw","_id":"cjm28whmt001g7rs6mxyf0c6b"},{"post_id":"cjm28whma00067rs6rpkgrn75","tag_id":"cjm28whmt001d7rs60hiv6mz1","_id":"cjm28whmu001i7rs6weiww8ub"},{"post_id":"cjm28whmd00097rs60ceuz6rj","tag_id":"cjm28whmr00177rs62tfziapw","_id":"cjm28whmu001l7rs6iitgirrq"},{"post_id":"cjm28whmd00097rs60ceuz6rj","tag_id":"cjm28whmr00147rs66rbvjmpi","_id":"cjm28whmu001m7rs6gafxx0pz"},{"post_id":"cjm28whmd00097rs60ceuz6rj","tag_id":"cjm28whmu001j7rs6gvr4z0gs","_id":"cjm28whmv001o7rs6y695ur6s"},{"post_id":"cjm28whme000a7rs6g1klc05e","tag_id":"cjm28whmr00147rs66rbvjmpi","_id":"cjm28whmw001s7rs6nm0lp0h3"},{"post_id":"cjm28whme000a7rs6g1klc05e","tag_id":"cjm28whmr00177rs62tfziapw","_id":"cjm28whmw001t7rs634phclnn"},{"post_id":"cjm28whme000a7rs6g1klc05e","tag_id":"cjm28whmv001p7rs609x68v4w","_id":"cjm28whmw001v7rs66ijryr0p"},{"post_id":"cjm28whme000a7rs6g1klc05e","tag_id":"cjm28whmt001d7rs60hiv6mz1","_id":"cjm28whmw001w7rs6v98wcs0h"},{"post_id":"cjm28whmf000e7rs6e0y4m1j8","tag_id":"cjm28whmj000i7rs6ybf1kixl","_id":"cjm28whmx001y7rs63mmb7a55"},{"post_id":"cjm28whmf000e7rs6e0y4m1j8","tag_id":"cjm28whmw001u7rs69wlbg7ga","_id":"cjm28whmx001z7rs6az1agcx3"},{"post_id":"cjm28whmh000g7rs6co63hq74","tag_id":"cjm28whmr00147rs66rbvjmpi","_id":"cjm28whmx00217rs6yt57gzj7"},{"post_id":"cjm28whmk000j7rs62oelxqxc","tag_id":"cjm28whmr00147rs66rbvjmpi","_id":"cjm28whmy00237rs6vkh6ekko"},{"post_id":"cjm28whml000m7rs6vjq3pkjz","tag_id":"cjm28whmj000i7rs6ybf1kixl","_id":"cjm28whmy00257rs6igu9l99q"},{"post_id":"cjm28whml000m7rs6vjq3pkjz","tag_id":"cjm28whmt001d7rs60hiv6mz1","_id":"cjm28whmy00267rs6aoqp11fa"},{"post_id":"cjm28whmm000q7rs6faa9zhbg","tag_id":"cjm28whmr00147rs66rbvjmpi","_id":"cjm28whmy00277rs6hna3zur7"}],"Tag":[{"name":"hexo","_id":"cjm28whm700037rs6cla6vr3s"},{"name":"AppVeyor","_id":"cjm28whmb00087rs6jh98xwhd"},{"name":"持续集成","_id":"cjm28whmf000d7rs6yrmep1cf"},{"name":"跨域","_id":"cjm28whmj000i7rs6ybf1kixl"},{"name":"jsonp","_id":"cjm28whmm000p7rs6qpnv2grc"},{"name":"promise","_id":"cjm28whmp000v7rs6ttks8bkm"},{"name":"异步同步","_id":"cjm28whmq000y7rs6b0b1ttk5"},{"name":"swiper-animal","_id":"cjm28whmq00117rs6cl96cvjs"},{"name":"webpack","_id":"cjm28whmr00147rs66rbvjmpi"},{"name":"vue-cli","_id":"cjm28whmr00177rs62tfziapw"},{"name":"vue","_id":"cjm28whmt001d7rs60hiv6mz1"},{"name":"nodejs","_id":"cjm28whmu001j7rs6gvr4z0gs"},{"name":"node","_id":"cjm28whmv001p7rs609x68v4w"},{"name":"代理","_id":"cjm28whmw001u7rs69wlbg7ga"}]}}